{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-4a4d0bd1da3c5f5c.js","src/scripts/cv.js","node_modules/marked/lib/marked.umd.js","node_modules/marked/src/marked.ts","node_modules/marked/src/defaults.ts","node_modules/marked/src/rules.ts","node_modules/marked/src/helpers.ts","node_modules/marked/src/Tokenizer.ts","node_modules/marked/src/Lexer.ts","node_modules/marked/src/Renderer.ts","node_modules/marked/src/TextRenderer.ts","node_modules/marked/src/Parser.ts","node_modules/marked/src/Hooks.ts","node_modules/marked/src/Instance.ts"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SERVER_PORT = 1234;var HMR_SECURE = false;var HMR_ENV_HASH = \"439701173a9199ea\";var HMR_USE_SSE = false;module.bundle.HMR_BUNDLE_ID = \"90e9e86d03c3c918\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: {|[string]: mixed|};\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_SERVER_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var HMR_USE_SSE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData[moduleName],\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData[moduleName] = undefined;\n}\nmodule.bundle.Module = Module;\nmodule.bundle.hotData = {};\nvar checkedAssets /*: {|[string]: boolean|} */,\n  disposedAssets /*: {|[string]: boolean|} */,\n  assetsToDispose /*: Array<[ParcelRequire, string]> */,\n  assetsToAccept /*: Array<[ParcelRequire, string]> */,\n  bundleNotFound = false;\nfunction getHostname() {\n  return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\nfunction getPort() {\n  return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);\n}\n\n// eslint-disable-next-line no-redeclare\nlet WebSocket = globalThis.WebSocket;\nif (!WebSocket && typeof module.bundle.root === 'function') {\n  try {\n    // eslint-disable-next-line no-global-assign\n    WebSocket = module.bundle.root('ws');\n  } catch {\n    // ignore.\n  }\n}\nvar hostname = getHostname();\nvar port = getPort();\nvar protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && !['localhost', '127.0.0.1', '0.0.0.0'].includes(hostname) ? 'wss' : 'ws';\n\n// eslint-disable-next-line no-redeclare\nvar parent = module.bundle.parent;\nif (!parent || !parent.isParcelRequire) {\n  // Web extension context\n  var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;\n\n  // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n  var supportsSourceURL = false;\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  }\n  var ws;\n  if (HMR_USE_SSE) {\n    ws = new EventSource('/__parcel_hmr');\n  } else {\n    try {\n      // If we're running in the dev server's node runner, listen for messages on the parent port.\n      let {\n        workerData,\n        parentPort\n      } = module.bundle.root('node:worker_threads') /*: any*/;\n      if (workerData !== null && workerData !== void 0 && workerData.__parcel) {\n        parentPort.on('message', async message => {\n          try {\n            await handleMessage(message);\n            parentPort.postMessage('updated');\n          } catch {\n            parentPort.postMessage('restart');\n          }\n        });\n\n        // After the bundle has finished running, notify the dev server that the HMR update is complete.\n        queueMicrotask(() => parentPort.postMessage('ready'));\n      }\n    } catch {\n      if (typeof WebSocket !== 'undefined') {\n        try {\n          ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');\n        } catch (err) {\n          // Ignore cloudflare workers error.\n          if (err.message && !err.message.includes('Disallowed operation called within global scope')) {\n            console.error(err.message);\n          }\n        }\n      }\n    }\n  }\n  if (ws) {\n    // $FlowFixMe\n    ws.onmessage = async function (event /*: {data: string, ...} */) {\n      var data /*: HMRMessage */ = JSON.parse(event.data);\n      await handleMessage(data);\n    };\n    if (ws instanceof WebSocket) {\n      ws.onerror = function (e) {\n        if (e.message) {\n          console.error(e.message);\n        }\n      };\n      ws.onclose = function () {\n        console.warn('[parcel]  Connection to the HMR server was lost');\n      };\n    }\n  }\n}\nasync function handleMessage(data /*: HMRMessage */) {\n  checkedAssets = {} /*: {|[string]: boolean|} */;\n  disposedAssets = {} /*: {|[string]: boolean|} */;\n  assetsToAccept = [];\n  assetsToDispose = [];\n  bundleNotFound = false;\n  if (data.type === 'reload') {\n    fullReload();\n  } else if (data.type === 'update') {\n    // Remove error overlay if there is one\n    if (typeof document !== 'undefined') {\n      removeErrorOverlay();\n    }\n    let assets = data.assets;\n\n    // Handle HMR Update\n    let handled = assets.every(asset => {\n      return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n    });\n\n    // Dispatch a custom event in case a bundle was not found. This might mean\n    // an asset on the server changed and we should reload the page. This event\n    // gives the client an opportunity to refresh without losing state\n    // (e.g. via React Server Components). If e.preventDefault() is not called,\n    // we will trigger a full page reload.\n    if (handled && bundleNotFound && assets.some(a => a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n      handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {\n        cancelable: true\n      }));\n    }\n    if (handled) {\n      console.clear();\n\n      // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n      if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n        window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n      }\n      await hmrApplyUpdates(assets);\n      hmrDisposeQueue();\n\n      // Run accept callbacks. This will also re-execute other disposed assets in topological order.\n      let processedAssets = {};\n      for (let i = 0; i < assetsToAccept.length; i++) {\n        let id = assetsToAccept[i][1];\n        if (!processedAssets[id]) {\n          hmrAccept(assetsToAccept[i][0], id);\n          processedAssets[id] = true;\n        }\n      }\n    } else fullReload();\n  }\n  if (data.type === 'error') {\n    // Log parcel errors to console\n    for (let ansiDiagnostic of data.diagnostics.ansi) {\n      let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n      console.error(' [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n    }\n    if (typeof document !== 'undefined') {\n      // Render the fancy html overlay\n      removeErrorOverlay();\n      var overlay = createErrorOverlay(data.diagnostics.html);\n      // $FlowFixMe\n      document.body.appendChild(overlay);\n    }\n  }\n}\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel]  Error resolved');\n  }\n}\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n           ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div> ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div> <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\nfunction fullReload() {\n  if (typeof location !== 'undefined' && 'reload' in location) {\n    location.reload();\n  } else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  } else {\n    try {\n      let {\n        workerData,\n        parentPort\n      } = module.bundle.root('node:worker_threads') /*: any*/;\n      if (workerData !== null && workerData !== void 0 && workerData.__parcel) {\n        parentPort.postMessage('restart');\n      }\n    } catch (err) {\n      console.error('[parcel]  An HMR update was not accepted. Please restart the process.');\n    }\n  }\n}\nfunction getParents(bundle, id) /*: Array<[ParcelRequire, string]> */{\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n  var parents = [];\n  var k, d, dep;\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n  return parents;\n}\nfunction updateLink(link) {\n  var href = link.getAttribute('href');\n  if (!href) {\n    return;\n  }\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n  newLink.setAttribute('href',\n  // $FlowFixMe\n  href.split('?')[0] + '?' + Date.now());\n  // $FlowFixMe\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout || typeof document === 'undefined') {\n    return;\n  }\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href /*: string */ = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n    cssTimeout = null;\n  }, 50);\n}\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n      return new Promise((resolve, reject) => {\n        var _document$head;\n        script.onload = () => resolve(script);\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension fix\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n            extCtx.runtime.reload();\n            return;\n          }\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n          (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\nfunction hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      }\n\n      // $FlowFixMe\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    }\n\n    // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.\n    // This is required in case modules are duplicated. We need to ensure all instances have the updated code.\n    if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    }\n\n    // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n    delete modules[id];\n    delete bundle.cache[id];\n\n    // Now delete the orphans.\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\nfunction hmrAcceptCheck(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  checkedAssets = {};\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  }\n\n  // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else if (a !== null) {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n      parents.push(...p);\n    }\n  }\n  return accepted;\n}\nfunction hmrAcceptCheckOne(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      bundleNotFound = true;\n      return true;\n    }\n    return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);\n  }\n  if (checkedAssets[id]) {\n    return null;\n  }\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  if (!cached) {\n    return true;\n  }\n  assetsToDispose.push([bundle, id]);\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    assetsToAccept.push([bundle, id]);\n    return true;\n  }\n  return false;\n}\nfunction hmrDisposeQueue() {\n  // Dispose all old assets.\n  for (let i = 0; i < assetsToDispose.length; i++) {\n    let id = assetsToDispose[i][1];\n    if (!disposedAssets[id]) {\n      hmrDispose(assetsToDispose[i][0], id);\n      disposedAssets[id] = true;\n    }\n  }\n  assetsToDispose = [];\n}\nfunction hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {\n  var cached = bundle.cache[id];\n  bundle.hotData[id] = {};\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData[id];\n  }\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData[id]);\n    });\n  }\n  delete bundle.cache[id];\n}\nfunction hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {\n  // Execute the module.\n  bundle(id);\n\n  // Run the accept callbacks in the new version of the module.\n  var cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    let assetsToAlsoAccept = [];\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      let additionalAssets = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n      if (Array.isArray(additionalAssets) && additionalAssets.length) {\n        assetsToAlsoAccept.push(...additionalAssets);\n      }\n    });\n    if (assetsToAlsoAccept.length) {\n      let handled = assetsToAlsoAccept.every(function (a) {\n        return hmrAcceptCheck(a[0], a[1]);\n      });\n      if (!handled) {\n        return fullReload();\n      }\n      hmrDisposeQueue();\n    }\n  }\n}","import { marked } from \"marked\";\n\nlet cvMd = `# Antonino Cilione\n**Big Data Engineer**\nReggio Calabria, Italy | (+39) 347-252-7757\nantoninocilione96@gmail.com | linkedin.com/in/antonino-cilione-1258291a6 | github.com/acilione | acilione.github.io\n\n### Professional Summary\nBig Data Engineer with extensive experience in designing scalable ETL pipelines and microservices. Proven track record in migrating legacy frameworks to modern cloud architectures and optimizing database performance. Specializes in the ingestion and processing of critical energy grid data, utilizing the Hadoop ecosystem (Spark, Kafka) and Cloud technologies.\n\n---\n\n### Work History\n\n**Big Data Engineer** | **Enel** | *Jul 2022  Present*\n* **Primary Responsibility:** Engineered and maintained high-throughput data pipelines specifically for the **ingestion of medium and low voltage measurements**, ensuring data accuracy and real-time availability for grid analysis.\n* **Framework Migration:** Led the complex framework migration from Cloudera Distribution Hadoop (CDH) to **Cloudera Data Platform (CDP)**, modernizing the data infrastructure.\n* **ETL Development:** Developed and maintained high-performance ETL pipelines using **Apache Spark** and **Kafka**.\n* **R&D & Optimization:** Researched and benchmarked **Apache Iceberg** functionalities using Spark and Flink; successfully implemented a custom \"equality delete files\" commit feature on Apache Spark.\n* **Data Ingestion:** Designed and implemented robust data ingestion flows using **Apache NiFi**.\n* **Database Management:** Optimized **MongoDB Atlas** clusters by tuning indexes, memory, and configuring auto-scaling to balance cost and performance.\n* **Microservices:** Developed **Java/Kotlin microservices** (Spring Boot) to expose NoSQL data stored on MongoDB to downstream applications.\n* **Automation:** Authored **Python scripts** for advanced S3 Parquet file operations (merge, deduplicate, backup, restore) and **Bash scripts** for automated Kafka/S3 status checks.\n* **Performance Tuning:** Integrated **Redis cache** (Redisson) within Spark jobs to reduce latency.\n* **Codebase Evolution:** Developed complex SQL procedures for data analysis and executed significant codebase refactoring.\n* *Tech Stack:* Kubernetes, Docker, Git, Dremio.\n\n**Android Developer** | **Iriscube Reply** | *Feb 2022  Jul 2022*\n* Developed and maintained a corporate Android banking application.\n* Migrated the codebase from **Java** to **Kotlin**.\n* Implemented new user-facing features and performed critical bug fixing to ensure app stability.\n\n---\n\n### Education\n\n**B.Eng. in Software Engineering** | **University of Catania** | *Oct 2018  Mar 2022*\n* **Thesis:** *Implementation of learning algorithms on microcontrollers.* Developed a Human Activity Recognition (HAR) model on an STM microcontroller using **TFLite**.\n\n---\n\n### Skills\n\n* **Data Technologies:** Apache Spark, Kafka, MongoDB Atlas, Apache NiFi, Redis, Dremio.\n* **Programming:** Java, Go, Kotlin, Python, Scala, C, SQL, Bash, TypeScript, C#.\n* **Frontend & Graphics:** React, Three.js, Unity.\n* **Frameworks and Libraries:** Spring Boot, React, TensorFlow Lite (TFLite).\n* **Cloud & DevOps:** Kubernetes, Docker, AWS (S3), Git.\n* **Languages:** English (Proficient), Italian (Native).\n\n---\n\n### Side Projects\n\n**Physics Simulations**\n* Implemented complex physics papers using **Three.js** to create realistic browser-based visualizations.\n* **Simulations developed:**\n    * *Heron's Fountain:* A fluid dynamics simulation demonstrating pneumatic and hydraulic pressure.\n    * *Unblowing bubbles: Understanding the physics of bubble deflation through a straw:* A simulation modeling surface tension and air pressure dynamics.\n    * *Boyle's Perpetual Movement Flask:* (In Progress) A simulation of the classic hydrostatic paradox.\n\n**Videogames & Interactive Media**\n* **Quantum Dungeon Crawler:** Designed a dungeon crawler where real quantum computing algorithms (Grover, Shor, Bernstein-Vazirani, VQE, QAOA) become core gameplay mechanics. Features an in-game circuit composer, temperature-driven decoherence system, and progressive level design teaching quantum concepts. (In Progress)\n* **Kamisado:** A full-featured real-time multiplayer Kamisado board game with sumo push mechanics, chess-style timers, and spectator mode. Built with **TypeScript**, **Node.js**, **Express**, and **Socket.IO**.\n* **Greta's Adventures:** Developed a full platform video game using **Unity** and **C#** (Awarded First Prize at University of Catania's Game Jam).\n* **Interactive Physics Lab:** Developing a fully interactive virtual physics laboratory using **React**, **TypeScript**, and **Three.js** (In Progress).\n\n**Other Engineering Projects**\n* **Computer Vision App:** Created an Android application enabling 3D model manipulation via computer vision using hand gestures.\n* **C Standard Library:** Re-implemented portions of the C Standard Library to deepen understanding of low-level memory management.\n\n---\n\n### Competitions\n\n* **MALLORN Astronomical Classification Challenge** (Kaggle): Classified astronomical transients to detect Tidal Disruption Events (stars torn apart by black holes). Ranked **58th out of 894** participants.\n\n---\n\n### Certifications\n\n* **Coursera:** The Data Scientists Toolbox - Johns Hopkins University\n* **Coursera:** Algorithm Toolbox - UC San Diego\n* **Coursera:** Improving Deep Neural Networks - DeepLearning.AI\n* **Coursera:** Getting and Cleaning Data - Johns Hopkins University\n* **Cambridge English:** First (FCE)\n`\ndocument.getElementById(\"cv-content\").innerHTML =\n    marked.parse(cvMd)",null,"import { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { Marked } from './Instance.ts';\nimport {\n  _getDefaults,\n  changeDefaults,\n  _defaults,\n} from './defaults.ts';\nimport type { MarkedExtension, MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, TokensList } from './Tokens.ts';\nimport type { MaybePromise } from './Instance.ts';\n\nconst markedInstance = new Marked();\n\n/**\n * Compiles markdown to HTML asynchronously.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options, having async: true\n * @return Promise of string of compiled HTML\n */\nexport function marked(src: string, options: MarkedOptions & { async: true }): Promise<string>;\n\n/**\n * Compiles markdown to HTML.\n *\n * @param src String of markdown source to be compiled\n * @param options Optional hash of options\n * @return String of compiled HTML. Will be a Promise of string if async is set to true by any extensions.\n */\nexport function marked(src: string, options: MarkedOptions & { async: false }): string;\nexport function marked(src: string, options: MarkedOptions & { async: true }): Promise<string>;\nexport function marked(src: string, options?: MarkedOptions | null): string | Promise<string>;\nexport function marked(src: string, opt?: MarkedOptions | null): string | Promise<string> {\n  return markedInstance.parse(src, opt);\n}\n\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\nmarked.setOptions = function(options: MarkedOptions) {\n  markedInstance.setOptions(options);\n  marked.defaults = markedInstance.defaults;\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\n\nmarked.defaults = _defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(...args: MarkedExtension[]) {\n  markedInstance.use(...args);\n  marked.defaults = markedInstance.defaults;\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n  return markedInstance.walkTokens(tokens, callback);\n};\n\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\n\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport { _defaults as defaults, _getDefaults as getDefaults } from './defaults.ts';\nexport { _Lexer as Lexer } from './Lexer.ts';\nexport { _Parser as Parser } from './Parser.ts';\nexport { _Tokenizer as Tokenizer } from './Tokenizer.ts';\nexport { _Renderer as Renderer } from './Renderer.ts';\nexport { _TextRenderer as TextRenderer } from './TextRenderer.ts';\nexport { _Hooks as Hooks } from './Hooks.ts';\nexport { Marked } from './Instance.ts';\nexport type * from './MarkedOptions.ts';\nexport type * from './Tokens.ts';\n","import type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Gets the original marked default options.\n */\nexport function _getDefaults<ParserOutput = string, RendererOutput = string>(): MarkedOptions<ParserOutput, RendererOutput> {\n  return {\n    async: false,\n    breaks: false,\n    extensions: null,\n    gfm: true,\n    hooks: null,\n    pedantic: false,\n    renderer: null,\n    silent: false,\n    tokenizer: null,\n    walkTokens: null,\n  };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport let _defaults: MarkedOptions<any, any> = _getDefaults();\n\nexport function changeDefaults<ParserOutput = string, RendererOutput = string>(newDefaults: MarkedOptions<ParserOutput, RendererOutput>) {\n  _defaults = newDefaults;\n}\n","const noopTest = { exec: () => null } as unknown as RegExp;\n\nfunction edit(regex: string | RegExp, opt = '') {\n  let source = typeof regex === 'string' ? regex : regex.source;\n  const obj = {\n    replace: (name: string | RegExp, val: string | RegExp) => {\n      let valSource = typeof val === 'string' ? val : val.source;\n      valSource = valSource.replace(other.caret, '$1');\n      source = source.replace(name, valSource);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(source, opt);\n    },\n  };\n  return obj;\n}\n\nexport const other = {\n  codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n  outputLinkReplace: /\\\\([\\[\\]])/g,\n  indentCodeCompensation: /^(\\s+)(?:```)/,\n  beginningSpace: /^\\s+/,\n  endingHash: /#$/,\n  startingSpaceChar: /^ /,\n  endingSpaceChar: / $/,\n  nonSpaceChar: /[^ ]/,\n  newLineCharGlobal: /\\n/g,\n  tabCharGlobal: /\\t/g,\n  multipleSpaceGlobal: /\\s+/g,\n  blankLine: /^[ \\t]*$/,\n  doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n  blockquoteStart: /^ {0,3}>/,\n  blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n  blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n  listReplaceTabs: /^\\t+/,\n  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n  listIsTask: /^\\[[ xX]\\] /,\n  listReplaceTask: /^\\[[ xX]\\] +/,\n  anyLine: /\\n.*\\n/,\n  hrefBrackets: /^<(.*)>$/,\n  tableDelimiter: /[:|]/,\n  tableAlignChars: /^\\||\\| *$/g,\n  tableRowBlankLine: /\\n[ \\t]*$/,\n  tableAlignRight: /^ *-+: *$/,\n  tableAlignCenter: /^ *:-+: *$/,\n  tableAlignLeft: /^ *:-+ *$/,\n  startATag: /^<a /i,\n  endATag: /^<\\/a>/i,\n  startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n  endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n  startAngleBracket: /^</,\n  endAngleBracket: />$/,\n  pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n  unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n  escapeTest: /[&<>\"']/,\n  escapeReplace: /[&<>\"']/g,\n  escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n  escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n  unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n  caret: /(^|[^\\[])\\^/g,\n  percentDecode: /%25/g,\n  findPipe: /\\|/g,\n  splitPipe: / \\|/,\n  slashPipe: /\\\\\\|/g,\n  carriageReturn: /\\r\\n|\\r/g,\n  spaceLine: /^ +$/gm,\n  notSpaceStart: /^\\S*/,\n  endingNewline: /\\n$/,\n  listItemRegex: (bull: string) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n  nextBulletRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n  hrRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n  fencesBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n  headingBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n  htmlBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n};\n\n/**\n * Block-Level Grammar\n */\n\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nconst lheading = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/\\|table/g, '') // table not in commonmark\n  .getRegex();\nconst lheadingGfm = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n  .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\[\\s\\S]|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n  .replace('label', _blockLabel)\n  .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n  .getRegex();\n\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n  .replace(/bull/g, bullet)\n  .getRegex();\n\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n  + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit(\n  '^ {0,3}(?:' // optional indentation\n+ '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n+ '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n+ '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n+ '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n+ '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n+ '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n+ '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n+ '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n+ ')', 'i')\n  .replace('comment', _comment)\n  .replace('tag', _tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst paragraph = edit(_paragraph)\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n  .replace('|table', '')\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n  .replace('paragraph', paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nconst blockNormal = {\n  blockquote,\n  code: blockCode,\n  def,\n  fences,\n  heading,\n  hr,\n  html,\n  lheading,\n  list,\n  newline,\n  paragraph,\n  table: noopTest,\n  text: blockText,\n};\n\ntype BlockKeys = keyof typeof blockNormal;\n\n/**\n * GFM Block Grammar\n */\n\nconst gfmTable = edit(\n  '^ *([^\\\\n ].*)\\\\n' // Header\n+ ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n+ '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockGfm: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  lheading: lheadingGfm,\n  table: gfmTable,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('table', gfmTable) // interrupt paragraphs with table\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex(),\n};\n\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nconst blockPedantic: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', _comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', lheading)\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .replace('|tag', '')\n    .getRegex(),\n};\n\n/**\n * Inline-Level Grammar\n */\n\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n  .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = edit(/link|code|html/, 'g')\n  .replace('link', /\\[(?:[^\\[\\]`]|(?<!`)(?<a>`+)[^`]+\\k<a>(?!`))*?\\]\\((?:\\\\[\\s\\S]|[^\\\\\\(\\)]|\\((?:\\\\[\\s\\S]|[^\\\\\\(\\)])*\\))*\\)/)\n  .replace('code', /(?<!`)(?<b>`+)[^`]+\\k<b>(?!`)/)\n  .replace('html', /<(?! )[^<>]*?>/)\n  .getRegex();\n\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\n\nconst emStrongLDelim = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\nconst emStrongRDelimAstCore =\n  '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n+ '|[^*]+(?=[^*])' // Consume to delim\n+ '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n+ '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n+ '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n+ '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\n\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n  .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\n  '^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n+ '|[^_]+(?=[^_])' // Consume to delim\n+ '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n+ '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n+ '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n+ '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n+ '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst anyPunctuation = edit(/\\\\(punct)/, 'gu')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n  .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n  .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n  .getRegex();\n\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit(\n  '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n  .replace('comment', _inlineComment)\n  .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst _inlineLabel = /(?:\\[(?:\\\\[\\s\\S]|[^\\[\\]\\\\])*\\]|\\\\[\\s\\S]|`+[^`]*?`+(?!`)|[^\\[\\]\\\\`])*?/;\n\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/)\n  .replace('label', _inlineLabel)\n  .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/)\n  .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n  .getRegex();\n\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n  .replace('label', _inlineLabel)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n  .replace('reflink', reflink)\n  .replace('nolink', nolink)\n  .getRegex();\n\nconst _caseInsensitiveProtocol = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/;\n\n/**\n * Normal Inline Grammar\n */\n\nconst inlineNormal = {\n  _backpedal: noopTest, // only used for GFM url\n  anyPunctuation,\n  autolink,\n  blockSkip,\n  br,\n  code: inlineCode,\n  del: noopTest,\n  emStrongLDelim,\n  emStrongRDelimAst,\n  emStrongRDelimUnd,\n  escape,\n  link,\n  nolink,\n  punctuation,\n  reflink,\n  reflinkSearch,\n  tag,\n  text: inlineText,\n  url: noopTest,\n};\n\ntype InlineKeys = keyof typeof inlineNormal;\n\n/**\n * Pedantic Inline Grammar\n */\n\nconst inlinePedantic: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', _inlineLabel)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', _inlineLabel)\n    .getRegex(),\n};\n\n/**\n * GFM Inline Grammar\n */\n\nconst inlineGfm: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  emStrongRDelimAst: emStrongRDelimAstGfm,\n  emStrongLDelim: emStrongLDelimGfm,\n  url: edit(/^((?:protocol):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/)\n    .replace('protocol', _caseInsensitiveProtocol)\n    .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n    .getRegex(),\n  _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])((?:\\\\[\\s\\S]|[^\\\\])*?(?:\\\\[\\s\\S]|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n  text: edit(/^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|protocol:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/)\n    .replace('protocol', _caseInsensitiveProtocol)\n    .getRegex(),\n};\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\nconst inlineBreaks: Record<InlineKeys, RegExp> = {\n  ...inlineGfm,\n  br: edit(br).replace('{2,}', '*').getRegex(),\n  text: edit(inlineGfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex(),\n};\n\n/**\n * exports\n */\n\nexport const block = {\n  normal: blockNormal,\n  gfm: blockGfm,\n  pedantic: blockPedantic,\n};\n\nexport const inline = {\n  normal: inlineNormal,\n  gfm: inlineGfm,\n  breaks: inlineBreaks,\n  pedantic: inlinePedantic,\n};\n\nexport interface Rules {\n  other: typeof other\n  block: Record<BlockKeys, RegExp>\n  inline: Record<InlineKeys, RegExp>\n}\n","import { other } from './rules.ts';\n\n/**\n * Helpers\n */\nconst escapeReplacements: { [index: string]: string } = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch: string) => escapeReplacements[ch];\n\nexport function escape(html: string, encode?: boolean) {\n  if (encode) {\n    if (other.escapeTest.test(html)) {\n      return html.replace(other.escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (other.escapeTestNoEncode.test(html)) {\n      return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nexport function unescape(html: string) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(other.unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nexport function cleanUrl(href: string) {\n  try {\n    href = encodeURI(href).replace(other.percentDecode, '%');\n  } catch {\n    return null;\n  }\n  return href;\n}\n\nexport function splitCells(tableRow: string, count?: number) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n      let escaped = false;\n      let curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(other.splitPipe);\n  let i = 0;\n\n  // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n  if (!cells[0].trim()) {\n    cells.shift();\n  }\n  if (cells.length > 0 && !cells.at(-1)?.trim()) {\n    cells.pop();\n  }\n\n  if (count) {\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) cells.push('');\n    }\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n  }\n  return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str: string, c: string, invert?: boolean) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.slice(0, l - suffLen);\n}\n\nexport function findClosingBracket(str: string, b: string) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n\n  let level = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  if (level > 0) {\n    return -2;\n  }\n\n  return -1;\n}\n","import { _defaults } from './defaults.ts';\nimport {\n  rtrim,\n  splitCells,\n  findClosingBracket,\n} from './helpers.ts';\nimport type { Rules } from './rules.ts';\nimport type { _Lexer } from './Lexer.ts';\nimport type { Links, Tokens, Token } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\nfunction outputLink(cap: string[], link: Pick<Tokens.Link, 'href' | 'title'>, raw: string, lexer: _Lexer, rules: Rules): Tokens.Link | Tokens.Image {\n  const href = link.href;\n  const title = link.title || null;\n  const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n\n  lexer.state.inLink = true;\n  const token: Tokens.Link | Tokens.Image = {\n    type: cap[0].charAt(0) === '!' ? 'image' : 'link',\n    raw,\n    href,\n    title,\n    text,\n    tokens: lexer.inlineTokens(text),\n  };\n  lexer.state.inLink = false;\n  return token;\n}\n\nfunction indentCodeCompensation(raw: string, text: string, rules: Rules) {\n  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(rules.other.beginningSpace);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nexport class _Tokenizer<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  rules!: Rules; // set by the lexer\n  lexer!: _Lexer<ParserOutput, RendererOutput>; // set by the lexer\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  space(src: string): Tokens.Space | undefined {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap && cap[0].length > 0) {\n      return {\n        type: 'space',\n        raw: cap[0],\n      };\n    }\n  }\n\n  code(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text,\n      };\n    }\n  }\n\n  fences(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n        text,\n      };\n    }\n  }\n\n  heading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      let text = cap[2].trim();\n\n      // remove trailing #s\n      if (this.rules.other.endingHash.test(text)) {\n        const trimmed = rtrim(text, '#');\n        if (this.options.pedantic) {\n          text = trimmed.trim();\n        } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text,\n        tokens: this.lexer.inline(text),\n      };\n    }\n  }\n\n  hr(src: string): Tokens.Hr | undefined {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: rtrim(cap[0], '\\n'),\n      };\n    }\n  }\n\n  blockquote(src: string): Tokens.Blockquote | undefined {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      let lines = rtrim(cap[0], '\\n').split('\\n');\n      let raw = '';\n      let text = '';\n      const tokens: Token[] = [];\n\n      while (lines.length > 0) {\n        let inBlockquote = false;\n        const currentLines = [];\n\n        let i;\n        for (i = 0; i < lines.length; i++) {\n          // get lines up to a continuation\n          if (this.rules.other.blockquoteStart.test(lines[i])) {\n            currentLines.push(lines[i]);\n            inBlockquote = true;\n          } else if (!inBlockquote) {\n            currentLines.push(lines[i]);\n          } else {\n            break;\n          }\n        }\n        lines = lines.slice(i);\n\n        const currentRaw = currentLines.join('\\n');\n        const currentText = currentRaw\n          // precede setext continuation with 4 spaces so it isn't a setext\n          .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n          .replace(this.rules.other.blockquoteSetextReplace2, '');\n        raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n        text = text ? `${text}\\n${currentText}` : currentText;\n\n        // parse blockquote lines as top level tokens\n        // merge paragraphs if this is a continuation\n        const top = this.lexer.state.top;\n        this.lexer.state.top = true;\n        this.lexer.blockTokens(currentText, tokens, true);\n        this.lexer.state.top = top;\n\n        // if there is no continuation then we are done\n        if (lines.length === 0) {\n          break;\n        }\n\n        const lastToken = tokens.at(-1);\n\n        if (lastToken?.type === 'code') {\n          // blockquote continuation cannot be preceded by a code block\n          break;\n        } else if (lastToken?.type === 'blockquote') {\n          // include continuation in nested blockquote\n          const oldToken = lastToken as Tokens.Blockquote;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.blockquote(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n          break;\n        } else if (lastToken?.type === 'list') {\n          // include continuation in nested list\n          const oldToken = lastToken as Tokens.List;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.list(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n          lines = newText.substring(tokens.at(-1)!.raw.length).split('\\n');\n          continue;\n        }\n      }\n\n      return {\n        type: 'blockquote',\n        raw,\n        tokens,\n        text,\n      };\n    }\n  }\n\n  list(src: string): Tokens.List | undefined {\n    let cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let bull = cap[1].trim();\n      const isordered = bull.length > 1;\n\n      const list: Tokens.List = {\n        type: 'list',\n        raw: '',\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: [],\n      };\n\n      bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n      if (this.options.pedantic) {\n        bull = isordered ? bull : '[*+-]';\n      }\n\n      // Get next list item\n      const itemRegex = this.rules.other.listItemRegex(bull);\n      let endsWithBlankLine = false;\n      // Check if current bullet point can start a new List Item\n      while (src) {\n        let endEarly = false;\n        let raw = '';\n        let itemContents = '';\n        if (!(cap = itemRegex.exec(src))) {\n          break;\n        }\n\n        if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n          break;\n        }\n\n        raw = cap[0];\n        src = src.substring(raw.length);\n\n        let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t: string) => ' '.repeat(3 * t.length));\n        let nextLine = src.split('\\n', 1)[0];\n        let blankLine = !line.trim();\n\n        let indent = 0;\n        if (this.options.pedantic) {\n          indent = 2;\n          itemContents = line.trimStart();\n        } else if (blankLine) {\n          indent = cap[1].length + 1;\n        } else {\n          indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n          itemContents = line.slice(indent);\n          indent += cap[1].length;\n        }\n\n        if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n          raw += nextLine + '\\n';\n          src = src.substring(nextLine.length + 1);\n          endEarly = true;\n        }\n\n        if (!endEarly) {\n          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n          const hrRegex = this.rules.other.hrRegex(indent);\n          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n\n          // Check if following lines should be included in List Item\n          while (src) {\n            const rawLine = src.split('\\n', 1)[0];\n            let nextLineWithoutTabs;\n            nextLine = rawLine;\n\n            // Re-align to follow commonmark nesting rules\n            if (this.options.pedantic) {\n              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n              nextLineWithoutTabs = nextLine;\n            } else {\n              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n            }\n\n            // End list item if found code fences\n            if (fencesBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new heading\n            if (headingBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of html block\n            if (htmlBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new bullet\n            if (nextBulletRegex.test(nextLine)) {\n              break;\n            }\n\n            // Horizontal rule found\n            if (hrRegex.test(nextLine)) {\n              break;\n            }\n\n            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n              itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n            } else {\n              // not enough indentation\n              if (blankLine) {\n                break;\n              }\n\n              // paragraph continuation unless last line was a different block level element\n              if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                break;\n              }\n              if (fencesBeginRegex.test(line)) {\n                break;\n              }\n              if (headingBeginRegex.test(line)) {\n                break;\n              }\n              if (hrRegex.test(line)) {\n                break;\n              }\n\n              itemContents += '\\n' + nextLine;\n            }\n\n            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n              blankLine = true;\n            }\n\n            raw += rawLine + '\\n';\n            src = src.substring(rawLine.length + 1);\n            line = nextLineWithoutTabs.slice(indent);\n          }\n        }\n\n        if (!list.loose) {\n          // If the previous item ended with a blank line, the list is loose\n          if (endsWithBlankLine) {\n            list.loose = true;\n          } else if (this.rules.other.doubleBlankLine.test(raw)) {\n            endsWithBlankLine = true;\n          }\n        }\n\n        let istask: RegExpExecArray | null = null;\n        let ischecked: boolean | undefined;\n        // Check for task list items\n        if (this.options.gfm) {\n          istask = this.rules.other.listIsTask.exec(itemContents);\n          if (istask) {\n            ischecked = istask[0] !== '[ ] ';\n            itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: !!istask,\n          checked: ischecked,\n          loose: false,\n          text: itemContents,\n          tokens: [],\n        });\n\n        list.raw += raw;\n      }\n\n      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n      const lastItem = list.items.at(-1);\n      if (lastItem) {\n        lastItem.raw = lastItem.raw.trimEnd();\n        lastItem.text = lastItem.text.trimEnd();\n      } else {\n        // not a list since there were no items\n        return;\n      }\n      list.raw = list.raw.trimEnd();\n\n      // Item child tokens handled here at end because we needed to have the final item to trim it first\n      for (let i = 0; i < list.items.length; i++) {\n        this.lexer.state.top = false;\n        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n        if (!list.loose) {\n          // Check if list should be loose\n          const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n\n          list.loose = hasMultipleLineBreaks;\n        }\n      }\n\n      // Set all items to loose if list is loose\n      if (list.loose) {\n        for (let i = 0; i < list.items.length; i++) {\n          list.items[i].loose = true;\n        }\n      }\n\n      return list;\n    }\n  }\n\n  html(src: string): Tokens.HTML | undefined {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      const token: Tokens.HTML = {\n        type: 'html',\n        block: true,\n        raw: cap[0],\n        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n        text: cap[0],\n      };\n      return token;\n    }\n  }\n\n  def(src: string): Tokens.Def | undefined {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n      return {\n        type: 'def',\n        tag,\n        raw: cap[0],\n        href,\n        title,\n      };\n    }\n  }\n\n  table(src: string): Tokens.Table | undefined {\n    const cap = this.rules.block.table.exec(src);\n    if (!cap) {\n      return;\n    }\n\n    if (!this.rules.other.tableDelimiter.test(cap[2])) {\n      // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n      return;\n    }\n\n    const headers = splitCells(cap[1]);\n    const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n    const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n\n    const item: Tokens.Table = {\n      type: 'table',\n      raw: cap[0],\n      header: [],\n      align: [],\n      rows: [],\n    };\n\n    if (headers.length !== aligns.length) {\n      // header and align columns must be equal, rows can be different.\n      return;\n    }\n\n    for (const align of aligns) {\n      if (this.rules.other.tableAlignRight.test(align)) {\n        item.align.push('right');\n      } else if (this.rules.other.tableAlignCenter.test(align)) {\n        item.align.push('center');\n      } else if (this.rules.other.tableAlignLeft.test(align)) {\n        item.align.push('left');\n      } else {\n        item.align.push(null);\n      }\n    }\n\n    for (let i = 0; i < headers.length; i++) {\n      item.header.push({\n        text: headers[i],\n        tokens: this.lexer.inline(headers[i]),\n        header: true,\n        align: item.align[i],\n      });\n    }\n\n    for (const row of rows) {\n      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n        return {\n          text: cell,\n          tokens: this.lexer.inline(cell),\n          header: false,\n          align: item.align[i],\n        };\n      }));\n    }\n\n    return item;\n  }\n\n  lheading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1],\n        tokens: this.lexer.inline(cap[1]),\n      };\n    }\n  }\n\n  paragraph(src: string): Tokens.Paragraph | undefined {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n        ? cap[1].slice(0, -1)\n        : cap[1];\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text,\n        tokens: this.lexer.inline(text),\n      };\n    }\n  }\n\n  text(src: string): Tokens.Text | undefined {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        tokens: this.lexer.inline(cap[0]),\n      };\n    }\n  }\n\n  escape(src: string): Tokens.Escape | undefined {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: cap[1],\n      };\n    }\n  }\n\n  tag(src: string): Tokens.Tag | undefined {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n        this.lexer.state.inLink = true;\n      } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n        this.lexer.state.inLink = false;\n      }\n      if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n        this.lexer.state.inRawBlock = true;\n      } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n        this.lexer.state.inRawBlock = false;\n      }\n\n      return {\n        type: 'html',\n        raw: cap[0],\n        inLink: this.lexer.state.inLink,\n        inRawBlock: this.lexer.state.inRawBlock,\n        block: false,\n        text: cap[0],\n      };\n    }\n  }\n\n  link(src: string): Tokens.Link | Tokens.Image | undefined {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const trimmedUrl = cap[2].trim();\n      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n        // commonmark requires matching angle brackets\n        if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n          return;\n        }\n\n        // ending angle bracket cannot be escaped\n        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n          return;\n        }\n      } else {\n        // find closing parenthesis\n        const lastParenIndex = findClosingBracket(cap[2], '()');\n        if (lastParenIndex === -2) {\n          // more open parens than closed\n          return;\n        }\n\n        if (lastParenIndex > -1) {\n          const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          const linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        // split pedantic href and title\n        const link = this.rules.other.pedanticHrefTitle.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n\n      href = href.trim();\n      if (this.rules.other.startAngleBracket.test(href)) {\n        if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n          // pedantic allows starting angle bracket without ending angle bracket\n          href = href.slice(1);\n        } else {\n          href = href.slice(1, -1);\n        }\n      }\n      return outputLink(cap, {\n        href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n        title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n      }, cap[0], this.lexer, this.rules);\n    }\n  }\n\n  reflink(src: string, links: Links): Tokens.Link | Tokens.Image | Tokens.Text | undefined {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n      || (cap = this.rules.inline.nolink.exec(src))) {\n      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const link = links[linkString.toLowerCase()];\n      if (!link) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text,\n        };\n      }\n      return outputLink(cap, link, cap[0], this.lexer, this.rules);\n    }\n  }\n\n  emStrong(src: string, maskedSrc: string, prevChar = ''): Tokens.Em | Tokens.Strong | undefined {\n    let match = this.rules.inline.emStrongLDelim.exec(src);\n    if (!match) return;\n\n    // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;\n\n    const nextChar = match[1] || match[2] || '';\n\n    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n      // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n      const lLength = [...match[0]].length - 1;\n      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n      const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src (move to lexer?)\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue; // skip single * in __abc*abc__\n\n        rLength = [...rDelim].length;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        } else if (match[5] || match[6]) { // either Left or Right Delim\n          if (lLength % 3 && !((lLength + rLength) % 3)) {\n            midDelimTotal += rLength;\n            continue; // CommonMark Emphasis Rules 9-10\n          }\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters. *a*** -> *a*\n        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n        // char length can be >1 for unicode characters;\n        const lastCharLength = [...match[0]][0].length;\n        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\n        // Create `em` if smallest delimiter has odd char count. *a***\n        if (Math.min(lLength, rLength) % 2) {\n          const text = raw.slice(1, -1);\n          return {\n            type: 'em',\n            raw,\n            text,\n            tokens: this.lexer.inlineTokens(text),\n          };\n        }\n\n        // Create 'strong' if smallest delimiter has even char count. **a***\n        const text = raw.slice(2, -2);\n        return {\n          type: 'strong',\n          raw,\n          text,\n          tokens: this.lexer.inlineTokens(text),\n        };\n      }\n    }\n  }\n\n  codespan(src: string): Tokens.Codespan | undefined {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text,\n      };\n    }\n  }\n\n  br(src: string): Tokens.Br | undefined {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0],\n      };\n    }\n  }\n\n  del(src: string): Tokens.Del | undefined {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[2],\n        tokens: this.lexer.inlineTokens(cap[2]),\n      };\n    }\n  }\n\n  autolink(src: string): Tokens.Link | undefined {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[1];\n        href = 'mailto:' + text;\n      } else {\n        text = cap[1];\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  url(src: string): Tokens.Link | undefined {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[0];\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n        } while (prevCapZero !== cap[0]);\n        text = cap[0];\n        if (cap[1] === 'www.') {\n          href = 'http://' + cap[0];\n        } else {\n          href = cap[0];\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  inlineText(src: string): Tokens.Text | undefined {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      const escaped = this.lexer.state.inRawBlock;\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        escaped,\n      };\n    }\n  }\n}\n","import { _Tokenizer } from './Tokenizer.ts';\nimport { _defaults } from './defaults.ts';\nimport { other, block, inline } from './rules.ts';\nimport type { Token, TokensList, Tokens } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Block Lexer\n */\nexport class _Lexer<ParserOutput = string, RendererOutput = string> {\n  tokens: TokensList;\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  state: {\n    inLink: boolean;\n    inRawBlock: boolean;\n    top: boolean;\n  };\n\n  private tokenizer: _Tokenizer<ParserOutput, RendererOutput>;\n  private inlineQueue: { src: string, tokens: Token[] }[];\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    // TokenList cannot be created in one go\n    this.tokens = [] as unknown as TokensList;\n    this.tokens.links = Object.create(null);\n    this.options = options || _defaults;\n    this.options.tokenizer = this.options.tokenizer || new _Tokenizer<ParserOutput, RendererOutput>();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n    this.tokenizer.lexer = this;\n    this.inlineQueue = [];\n    this.state = {\n      inLink: false,\n      inRawBlock: false,\n      top: true,\n    };\n\n    const rules = {\n      other,\n      block: block.normal,\n      inline: inline.normal,\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline,\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex<ParserOutput = string, RendererOutput = string>(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const lexer = new _Lexer<ParserOutput, RendererOutput>(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline<ParserOutput = string, RendererOutput = string>(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const lexer = new _Lexer<ParserOutput, RendererOutput>(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src: string) {\n    src = src.replace(other.carriageReturn, '\\n');\n\n    this.blockTokens(src, this.tokens);\n\n    for (let i = 0; i < this.inlineQueue.length; i++) {\n      const next = this.inlineQueue[i];\n      this.inlineTokens(next.src, next.tokens);\n    }\n    this.inlineQueue = [];\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src: string, tokens?: Token[], lastParagraphClipped?: boolean): Token[];\n  blockTokens(src: string, tokens?: TokensList, lastParagraphClipped?: boolean): TokensList;\n  blockTokens(src: string, tokens: Token[] = [], lastParagraphClipped = false) {\n    if (this.options.pedantic) {\n      src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n    }\n\n    while (src) {\n      let token: Tokens.Generic | undefined;\n\n      if (this.options.extensions?.block?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.raw.length === 1 && lastToken !== undefined) {\n          // if there's a single \\n as a spacer, it's terminating the last line,\n          // so move it there so that we don't get unnecessary paragraph tags\n          lastToken.raw += '\\n';\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (token = this.tokenizer.def(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.raw;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title,\n          };\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      // prevent paragraph consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startBlock) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startBlock.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n        const lastToken = tokens.at(-1);\n        if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        lastParagraphClipped = cutSrc.length !== src.length;\n        src = src.substring(token.raw.length);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += (lastToken.raw.endsWith('\\n') ? '' : '\\n') + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    this.state.top = true;\n    return tokens;\n  }\n\n  inline(src: string, tokens: Token[] = []) {\n    this.inlineQueue.push({ src, tokens });\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src: string, tokens: Token[] = []): Token[] {\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match: RegExpExecArray | null = null;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index)\n              + '[' + 'a'.repeat(match[0].length - 2) + ']'\n              + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n\n    // Mask out escaped characters\n    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n    }\n\n    // Mask out other blocks\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    // Mask out blocks from extensions\n    maskedSrc = this.options.hooks?.emStrongMask?.call({ lexer: this }, maskedSrc) ?? maskedSrc;\n\n    let keepPrevChar = false;\n    let prevChar = '';\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n\n      let token: Tokens.Generic | undefined;\n\n      // extensions\n      if (this.options.extensions?.inline?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.type === 'text' && lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // em & strong\n      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      // prevent inlineText consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startInline) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startInline.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (token = this.tokenizer.inlineText(cutSrc)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n          prevChar = token.raw.slice(-1);\n        }\n        keepPrevChar = true;\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n}\n","import { _defaults } from './defaults.ts';\nimport {\n  cleanUrl,\n  escape,\n} from './helpers.ts';\nimport { other } from './rules.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\nimport type { Tokens } from './Tokens.ts';\nimport type { _Parser } from './Parser.ts';\n\n/**\n * Renderer\n */\nexport class _Renderer<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  parser!: _Parser<ParserOutput, RendererOutput>; // set by the parser\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  space(token: Tokens.Space): RendererOutput {\n    return '' as RendererOutput;\n  }\n\n  code({ text, lang, escaped }: Tokens.Code): RendererOutput {\n    const langString = (lang || '').match(other.notSpaceStart)?.[0];\n\n    const code = text.replace(other.endingNewline, '') + '\\n';\n\n    if (!langString) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n' as RendererOutput;\n    }\n\n    return '<pre><code class=\"language-'\n      + escape(langString)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n' as RendererOutput;\n  }\n\n  blockquote({ tokens }: Tokens.Blockquote): RendererOutput {\n    const body = this.parser.parse(tokens);\n    return `<blockquote>\\n${body}</blockquote>\\n` as RendererOutput;\n  }\n\n  html({ text }: Tokens.HTML | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  def(token: Tokens.Def): RendererOutput {\n    return '' as RendererOutput;\n  }\n\n  heading({ tokens, depth }: Tokens.Heading): RendererOutput {\n    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n` as RendererOutput;\n  }\n\n  hr(token: Tokens.Hr): RendererOutput {\n    return '<hr>\\n' as RendererOutput;\n  }\n\n  list(token: Tokens.List): RendererOutput {\n    const ordered = token.ordered;\n    const start = token.start;\n\n    let body = '';\n    for (let j = 0; j < token.items.length; j++) {\n      const item = token.items[j];\n      body += this.listitem(item);\n    }\n\n    const type = ordered ? 'ol' : 'ul';\n    const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n' as RendererOutput;\n  }\n\n  listitem(item: Tokens.ListItem): RendererOutput {\n    let itemBody = '';\n    if (item.task) {\n      const checkbox = this.checkbox({ checked: !!item.checked });\n      if (item.loose) {\n        if (item.tokens[0]?.type === 'paragraph') {\n          item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n            item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);\n            item.tokens[0].tokens[0].escaped = true;\n          }\n        } else {\n          item.tokens.unshift({\n            type: 'text',\n            raw: checkbox + ' ',\n            text: checkbox + ' ',\n            escaped: true,\n          });\n        }\n      } else {\n        itemBody += checkbox + ' ';\n      }\n    }\n\n    itemBody += this.parser.parse(item.tokens, !!item.loose);\n\n    return `<li>${itemBody}</li>\\n` as RendererOutput;\n  }\n\n  checkbox({ checked }: Tokens.Checkbox): RendererOutput {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\">' as RendererOutput;\n  }\n\n  paragraph({ tokens }: Tokens.Paragraph): RendererOutput {\n    return `<p>${this.parser.parseInline(tokens)}</p>\\n` as RendererOutput;\n  }\n\n  table(token: Tokens.Table): RendererOutput {\n    let header = '';\n\n    // header\n    let cell = '';\n    for (let j = 0; j < token.header.length; j++) {\n      cell += this.tablecell(token.header[j]);\n    }\n    header += this.tablerow({ text: cell as ParserOutput });\n\n    let body = '';\n    for (let j = 0; j < token.rows.length; j++) {\n      const row = token.rows[j];\n\n      cell = '';\n      for (let k = 0; k < row.length; k++) {\n        cell += this.tablecell(row[k]);\n      }\n\n      body += this.tablerow({ text: cell as ParserOutput });\n    }\n    if (body) body = `<tbody>${body}</tbody>`;\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n' as RendererOutput;\n  }\n\n  tablerow({ text }: Tokens.TableRow<ParserOutput>): RendererOutput {\n    return `<tr>\\n${text}</tr>\\n` as RendererOutput;\n  }\n\n  tablecell(token: Tokens.TableCell): RendererOutput {\n    const content = this.parser.parseInline(token.tokens);\n    const type = token.header ? 'th' : 'td';\n    const tag = token.align\n      ? `<${type} align=\"${token.align}\">`\n      : `<${type}>`;\n    return tag + content + `</${type}>\\n` as RendererOutput;\n  }\n\n  /**\n   * span level renderer\n   */\n  strong({ tokens }: Tokens.Strong): RendererOutput {\n    return `<strong>${this.parser.parseInline(tokens)}</strong>` as RendererOutput;\n  }\n\n  em({ tokens }: Tokens.Em): RendererOutput {\n    return `<em>${this.parser.parseInline(tokens)}</em>` as RendererOutput;\n  }\n\n  codespan({ text }: Tokens.Codespan): RendererOutput {\n    return `<code>${escape(text, true)}</code>` as RendererOutput;\n  }\n\n  br(token: Tokens.Br): RendererOutput {\n    return '<br>' as RendererOutput;\n  }\n\n  del({ tokens }: Tokens.Del): RendererOutput {\n    return `<del>${this.parser.parseInline(tokens)}</del>` as RendererOutput;\n  }\n\n  link({ href, title, tokens }: Tokens.Link): RendererOutput {\n    const text = this.parser.parseInline(tokens) as string;\n    const cleanHref = cleanUrl(href);\n    if (cleanHref === null) {\n      return text as RendererOutput;\n    }\n    href = cleanHref;\n    let out = '<a href=\"' + href + '\"';\n    if (title) {\n      out += ' title=\"' + (escape(title)) + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out as RendererOutput;\n  }\n\n  image({ href, title, text, tokens }: Tokens.Image): RendererOutput {\n    if (tokens) {\n      text = this.parser.parseInline(tokens, this.parser.textRenderer) as string;\n    }\n    const cleanHref = cleanUrl(href);\n    if (cleanHref === null) {\n      return escape(text) as RendererOutput;\n    }\n    href = cleanHref;\n\n    let out = `<img src=\"${href}\" alt=\"${text}\"`;\n    if (title) {\n      out += ` title=\"${escape(title)}\"`;\n    }\n    out += '>';\n    return out as RendererOutput;\n  }\n\n  text(token: Tokens.Text | Tokens.Escape): RendererOutput {\n    return 'tokens' in token && token.tokens\n      ? this.parser.parseInline(token.tokens) as unknown as RendererOutput\n      : ('escaped' in token && token.escaped ? token.text as RendererOutput : escape(token.text) as RendererOutput);\n  }\n}\n","import type { Tokens } from './Tokens.ts';\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer<RendererOutput = string> {\n  // no need for block level renderers\n  strong({ text }: Tokens.Strong): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  em({ text }: Tokens.Em): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  codespan({ text }: Tokens.Codespan): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  del({ text }: Tokens.Del): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  html({ text }: Tokens.HTML | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  text({ text }: Tokens.Text | Tokens.Escape | Tokens.Tag): RendererOutput {\n    return text as RendererOutput;\n  }\n\n  link({ text }: Tokens.Link): RendererOutput {\n    return '' + text as RendererOutput;\n  }\n\n  image({ text }: Tokens.Image): RendererOutput {\n    return '' + text as RendererOutput;\n  }\n\n  br(): RendererOutput {\n    return '' as RendererOutput;\n  }\n}\n","import { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _defaults } from './defaults.ts';\nimport type { MarkedToken, Token, Tokens } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Parsing & Compiling\n */\nexport class _Parser<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  renderer: _Renderer<ParserOutput, RendererOutput>;\n  textRenderer: _TextRenderer<RendererOutput>;\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n    this.options.renderer = this.options.renderer || new _Renderer<ParserOutput, RendererOutput>();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.renderer.parser = this;\n    this.textRenderer = new _TextRenderer<RendererOutput>();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse<ParserOutput = string, RendererOutput = string>(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const parser = new _Parser<ParserOutput, RendererOutput>(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline<ParserOutput = string, RendererOutput = string>(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    const parser = new _Parser<ParserOutput, RendererOutput>(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens: Token[], top = true): ParserOutput {\n    let out = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const anyToken = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions?.renderers?.[anyToken.type]) {\n        const genericToken = anyToken as Tokens.Generic;\n        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'def', 'paragraph', 'text'].includes(genericToken.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      const token = anyToken as MarkedToken;\n\n      switch (token.type) {\n        case 'space': {\n          out += this.renderer.space(token);\n          continue;\n        }\n        case 'hr': {\n          out += this.renderer.hr(token);\n          continue;\n        }\n        case 'heading': {\n          out += this.renderer.heading(token);\n          continue;\n        }\n        case 'code': {\n          out += this.renderer.code(token);\n          continue;\n        }\n        case 'table': {\n          out += this.renderer.table(token);\n          continue;\n        }\n        case 'blockquote': {\n          out += this.renderer.blockquote(token);\n          continue;\n        }\n        case 'list': {\n          out += this.renderer.list(token);\n          continue;\n        }\n        case 'html': {\n          out += this.renderer.html(token);\n          continue;\n        }\n        case 'def': {\n          out += this.renderer.def(token);\n          continue;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(token);\n          continue;\n        }\n        case 'text': {\n          let textToken = token;\n          let body = this.renderer.text(textToken) as string;\n          while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n            textToken = tokens[++i] as Tokens.Text;\n            body += ('\\n' + this.renderer.text(textToken));\n          }\n          if (top) {\n            out += this.renderer.paragraph({\n              type: 'paragraph',\n              raw: body,\n              text: body,\n              tokens: [{ type: 'text', raw: body, text: body, escaped: true }],\n            });\n          } else {\n            out += body;\n          }\n          continue;\n        }\n\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return '' as ParserOutput;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out as ParserOutput;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens: Token[], renderer: _Renderer<ParserOutput, RendererOutput> | _TextRenderer<RendererOutput> = this.renderer): ParserOutput {\n    let out = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const anyToken = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions?.renderers?.[anyToken.type]) {\n        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      const token = anyToken as MarkedToken;\n\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token);\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(token);\n          break;\n        }\n        case 'em': {\n          out += renderer.em(token);\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token);\n          break;\n        }\n        case 'br': {\n          out += renderer.br(token);\n          break;\n        }\n        case 'del': {\n          out += renderer.del(token);\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return '' as ParserOutput;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out as ParserOutput;\n  }\n}\n","import { _defaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, TokensList } from './Tokens.ts';\n\nexport class _Hooks<ParserOutput = string, RendererOutput = string> {\n  options: MarkedOptions<ParserOutput, RendererOutput>;\n  block?: boolean;\n\n  constructor(options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.options = options || _defaults;\n  }\n\n  static passThroughHooks = new Set([\n    'preprocess',\n    'postprocess',\n    'processAllTokens',\n    'emStrongMask',\n  ]);\n\n  static passThroughHooksRespectAsync = new Set([\n    'preprocess',\n    'postprocess',\n    'processAllTokens',\n  ]);\n\n  /**\n   * Process markdown before marked\n   */\n  preprocess(markdown: string) {\n    return markdown;\n  }\n\n  /**\n   * Process HTML after marked is finished\n   */\n  postprocess(html: ParserOutput) {\n    return html;\n  }\n\n  /**\n   * Process all tokens before walk tokens\n   */\n  processAllTokens(tokens: Token[] | TokensList) {\n    return tokens;\n  }\n\n  /**\n   * Mask contents that should not be interpreted as em/strong delimiters\n   */\n  emStrongMask(src: string) {\n    return src;\n  }\n\n  /**\n   * Provide function to tokenize markdown\n   */\n  provideLexer() {\n    return this.block ? _Lexer.lex : _Lexer.lexInline;\n  }\n\n  /**\n   * Provide function to parse tokens\n   */\n  provideParser() {\n    return this.block ? _Parser.parse<ParserOutput, RendererOutput> : _Parser.parseInline<ParserOutput, RendererOutput>;\n  }\n}\n","import { _getDefaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { escape } from './helpers.ts';\nimport type { MarkedExtension, MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, Tokens, TokensList } from './Tokens.ts';\n\nexport type MaybePromise = void | Promise<void>;\n\ntype UnknownFunction = (...args: unknown[]) => unknown;\ntype GenericRendererFunction = (...args: unknown[]) => string | false;\n\nexport class Marked<ParserOutput = string, RendererOutput = string> {\n  defaults = _getDefaults<ParserOutput, RendererOutput>();\n  options = this.setOptions;\n\n  parse = this.parseMarkdown(true);\n  parseInline = this.parseMarkdown(false);\n\n  Parser = _Parser<ParserOutput, RendererOutput>;\n  Renderer = _Renderer<ParserOutput, RendererOutput>;\n  TextRenderer = _TextRenderer<RendererOutput>;\n  Lexer = _Lexer;\n  Tokenizer = _Tokenizer<ParserOutput, RendererOutput>;\n  Hooks = _Hooks<ParserOutput, RendererOutput>;\n\n  constructor(...args: MarkedExtension<ParserOutput, RendererOutput>[]) {\n    this.use(...args);\n  }\n\n  /**\n   * Run callback for every token\n   */\n  walkTokens(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n    let values: MaybePromise[] = [];\n    for (const token of tokens) {\n      values = values.concat(callback.call(this, token));\n      switch (token.type) {\n        case 'table': {\n          const tableToken = token as Tokens.Table;\n          for (const cell of tableToken.header) {\n            values = values.concat(this.walkTokens(cell.tokens, callback));\n          }\n          for (const row of tableToken.rows) {\n            for (const cell of row) {\n              values = values.concat(this.walkTokens(cell.tokens, callback));\n            }\n          }\n          break;\n        }\n        case 'list': {\n          const listToken = token as Tokens.List;\n          values = values.concat(this.walkTokens(listToken.items, callback));\n          break;\n        }\n        default: {\n          const genericToken = token as Tokens.Generic;\n          if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n              const tokens = genericToken[childTokens].flat(Infinity) as Token[] | TokensList;\n              values = values.concat(this.walkTokens(tokens, callback));\n            });\n          } else if (genericToken.tokens) {\n            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n          }\n        }\n      }\n    }\n    return values;\n  }\n\n  use(...args: MarkedExtension<ParserOutput, RendererOutput>[]) {\n    const extensions: MarkedOptions<ParserOutput, RendererOutput>['extensions'] = this.defaults.extensions || { renderers: {}, childTokens: {} };\n\n    args.forEach((pack) => {\n      // copy options to new object\n      const opts = { ...pack } as MarkedOptions<ParserOutput, RendererOutput>;\n\n      // set async to true if it was set to true before\n      opts.async = this.defaults.async || opts.async || false;\n\n      // ==-- Parse \"addon\" extensions --== //\n      if (pack.extensions) {\n        pack.extensions.forEach((ext) => {\n          if (!ext.name) {\n            throw new Error('extension name required');\n          }\n          if ('renderer' in ext) { // Renderer extensions\n            const prevRenderer = extensions.renderers[ext.name];\n            if (prevRenderer) {\n              // Replace extension with func to run new extension but fall back if false\n              extensions.renderers[ext.name] = function(...args) {\n                let ret = ext.renderer.apply(this, args);\n                if (ret === false) {\n                  ret = prevRenderer.apply(this, args);\n                }\n                return ret;\n              };\n            } else {\n              extensions.renderers[ext.name] = ext.renderer;\n            }\n          }\n          if ('tokenizer' in ext) { // Tokenizer Extensions\n            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n              throw new Error(\"extension level must be 'block' or 'inline'\");\n            }\n            const extLevel = extensions[ext.level];\n            if (extLevel) {\n              extLevel.unshift(ext.tokenizer);\n            } else {\n              extensions[ext.level] = [ext.tokenizer];\n            }\n            if (ext.start) { // Function to check for start of token\n              if (ext.level === 'block') {\n                if (extensions.startBlock) {\n                  extensions.startBlock.push(ext.start);\n                } else {\n                  extensions.startBlock = [ext.start];\n                }\n              } else if (ext.level === 'inline') {\n                if (extensions.startInline) {\n                  extensions.startInline.push(ext.start);\n                } else {\n                  extensions.startInline = [ext.start];\n                }\n              }\n            }\n          }\n          if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n            extensions.childTokens[ext.name] = ext.childTokens;\n          }\n        });\n        opts.extensions = extensions;\n      }\n\n      // ==-- Parse \"overwrite\" extensions --== //\n      if (pack.renderer) {\n        const renderer = this.defaults.renderer || new _Renderer<ParserOutput, RendererOutput>(this.defaults);\n        for (const prop in pack.renderer) {\n          if (!(prop in renderer)) {\n            throw new Error(`renderer '${prop}' does not exist`);\n          }\n          if (['options', 'parser'].includes(prop)) {\n            // ignore options property\n            continue;\n          }\n          const rendererProp = prop as Exclude<keyof _Renderer<ParserOutput, RendererOutput>, 'options' | 'parser'>;\n          const rendererFunc = pack.renderer[rendererProp] as GenericRendererFunction;\n          const prevRenderer = renderer[rendererProp] as GenericRendererFunction;\n          // Replace renderer with func to run extension, but fall back if false\n          renderer[rendererProp] = (...args: unknown[]) => {\n            let ret = rendererFunc.apply(renderer, args);\n            if (ret === false) {\n              ret = prevRenderer.apply(renderer, args);\n            }\n            return (ret || '') as RendererOutput;\n          };\n        }\n        opts.renderer = renderer;\n      }\n      if (pack.tokenizer) {\n        const tokenizer = this.defaults.tokenizer || new _Tokenizer<ParserOutput, RendererOutput>(this.defaults);\n        for (const prop in pack.tokenizer) {\n          if (!(prop in tokenizer)) {\n            throw new Error(`tokenizer '${prop}' does not exist`);\n          }\n          if (['options', 'rules', 'lexer'].includes(prop)) {\n            // ignore options, rules, and lexer properties\n            continue;\n          }\n          const tokenizerProp = prop as Exclude<keyof _Tokenizer<ParserOutput, RendererOutput>, 'options' | 'rules' | 'lexer'>;\n          const tokenizerFunc = pack.tokenizer[tokenizerProp] as UnknownFunction;\n          const prevTokenizer = tokenizer[tokenizerProp] as UnknownFunction;\n          // Replace tokenizer with func to run extension, but fall back if false\n          // @ts-expect-error cannot type tokenizer function dynamically\n          tokenizer[tokenizerProp] = (...args: unknown[]) => {\n            let ret = tokenizerFunc.apply(tokenizer, args);\n            if (ret === false) {\n              ret = prevTokenizer.apply(tokenizer, args);\n            }\n            return ret;\n          };\n        }\n        opts.tokenizer = tokenizer;\n      }\n\n      // ==-- Parse Hooks extensions --== //\n      if (pack.hooks) {\n        const hooks = this.defaults.hooks || new _Hooks<ParserOutput, RendererOutput>();\n        for (const prop in pack.hooks) {\n          if (!(prop in hooks)) {\n            throw new Error(`hook '${prop}' does not exist`);\n          }\n          if (['options', 'block'].includes(prop)) {\n            // ignore options and block properties\n            continue;\n          }\n          const hooksProp = prop as Exclude<keyof _Hooks<ParserOutput, RendererOutput>, 'options' | 'block'>;\n          const hooksFunc = pack.hooks[hooksProp] as UnknownFunction;\n          const prevHook = hooks[hooksProp] as UnknownFunction;\n          if (_Hooks.passThroughHooks.has(prop)) {\n            // @ts-expect-error cannot type hook function dynamically\n            hooks[hooksProp] = (arg: unknown) => {\n              if (this.defaults.async && _Hooks.passThroughHooksRespectAsync.has(prop)) {\n                return (async() => {\n                  const ret = await hooksFunc.call(hooks, arg);\n                  return prevHook.call(hooks, ret);\n                })();\n              }\n\n              const ret = hooksFunc.call(hooks, arg);\n              return prevHook.call(hooks, ret);\n            };\n          } else {\n            // @ts-expect-error cannot type hook function dynamically\n            hooks[hooksProp] = (...args: unknown[]) => {\n              if (this.defaults.async) {\n                return (async() => {\n                  let ret = await hooksFunc.apply(hooks, args);\n                  if (ret === false) {\n                    ret = await prevHook.apply(hooks, args);\n                  }\n                  return ret;\n                })();\n              }\n\n              let ret = hooksFunc.apply(hooks, args);\n              if (ret === false) {\n                ret = prevHook.apply(hooks, args);\n              }\n              return ret;\n            };\n          }\n        }\n        opts.hooks = hooks;\n      }\n\n      // ==-- Parse WalkTokens extensions --== //\n      if (pack.walkTokens) {\n        const walkTokens = this.defaults.walkTokens;\n        const packWalktokens = pack.walkTokens;\n        opts.walkTokens = function(token) {\n          let values: MaybePromise[] = [];\n          values.push(packWalktokens.call(this, token));\n          if (walkTokens) {\n            values = values.concat(walkTokens.call(this, token));\n          }\n          return values;\n        };\n      }\n\n      this.defaults = { ...this.defaults, ...opts };\n    });\n\n    return this;\n  }\n\n  setOptions(opt: MarkedOptions<ParserOutput, RendererOutput>) {\n    this.defaults = { ...this.defaults, ...opt };\n    return this;\n  }\n\n  lexer(src: string, options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    return _Lexer.lex(src, options ?? this.defaults);\n  }\n\n  parser(tokens: Token[], options?: MarkedOptions<ParserOutput, RendererOutput>) {\n    return _Parser.parse<ParserOutput, RendererOutput>(tokens, options ?? this.defaults);\n  }\n\n  private parseMarkdown(blockType: boolean) {\n    type overloadedParse = {\n      (src: string, options: MarkedOptions<ParserOutput, RendererOutput> & { async: true }): Promise<ParserOutput>;\n      (src: string, options: MarkedOptions<ParserOutput, RendererOutput> & { async: false }): ParserOutput;\n      (src: string, options?: MarkedOptions<ParserOutput, RendererOutput> | null): ParserOutput | Promise<ParserOutput>;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const parse: overloadedParse = (src: string, options?: MarkedOptions<ParserOutput, RendererOutput> | null): any => {\n      const origOpt = { ...options };\n      const opt = { ...this.defaults, ...origOpt };\n\n      const throwError = this.onError(!!opt.silent, !!opt.async);\n\n      // throw error if an extension set async to true but parse was called with async: false\n      if (this.defaults.async === true && origOpt.async === false) {\n        return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n      }\n\n      // throw error in case of non string input\n      if (typeof src === 'undefined' || src === null) {\n        return throwError(new Error('marked(): input parameter is undefined or null'));\n      }\n      if (typeof src !== 'string') {\n        return throwError(new Error('marked(): input parameter is of type '\n          + Object.prototype.toString.call(src) + ', string expected'));\n      }\n\n      if (opt.hooks) {\n        opt.hooks.options = opt;\n        opt.hooks.block = blockType;\n      }\n\n      if (opt.async) {\n        return (async() => {\n          const processedSrc = opt.hooks ? await opt.hooks.preprocess(src) : src;\n          const lexer = opt.hooks ? await opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n          const tokens = await lexer(processedSrc, opt);\n          const processedTokens = opt.hooks ? await opt.hooks.processAllTokens(tokens) : tokens;\n          if (opt.walkTokens) {\n            await Promise.all(this.walkTokens(processedTokens, opt.walkTokens));\n          }\n          const parser = opt.hooks ? await opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n          const html = await parser(processedTokens, opt);\n          return opt.hooks ? await opt.hooks.postprocess(html) : html;\n        })().catch(throwError);\n      }\n\n      try {\n        if (opt.hooks) {\n          src = opt.hooks.preprocess(src) as string;\n        }\n        const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n        let tokens = lexer(src, opt);\n        if (opt.hooks) {\n          tokens = opt.hooks.processAllTokens(tokens);\n        }\n        if (opt.walkTokens) {\n          this.walkTokens(tokens, opt.walkTokens);\n        }\n        const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n        let html = parser(tokens, opt);\n        if (opt.hooks) {\n          html = opt.hooks.postprocess(html);\n        }\n        return html;\n      } catch(e) {\n        return throwError(e as Error);\n      }\n    };\n\n    return parse;\n  }\n\n  private onError(silent: boolean, async: boolean) {\n    return (e: Error): string | Promise<string> => {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (silent) {\n        const msg = '<p>An error occurred:</p><pre>'\n          + escape(e.message + '', true)\n          + '</pre>';\n        if (async) {\n          return Promise.resolve(msg);\n        }\n        return msg;\n      }\n\n      if (async) {\n        return Promise.reject(e);\n      }\n      throw e;\n    };\n  }\n}\n"],"names":["marked_exports","__export","_Hooks","_Lexer","Marked","_Parser","_Renderer","_TextRenderer","_Tokenizer","_defaults","_getDefaults","lexer","marked","options","parse","parseInline","parser","setOptions","use","walkTokens","__toCommonJS","changeDefaults","newDefaults","noopTest","edit","regex","opt","source","obj","name","val","valSource","other","bull","indent","newline","blockCode","fences","hr","heading","bullet","lheadingCore","lheading","lheadingGfm","_paragraph","blockText","_blockLabel","def","list","_tag","_comment","html","paragraph","blockquote","blockNormal","gfmTable","blockGfm","blockPedantic","escape","inlineCode","br","inlineText","_punctuation","_punctuationOrSpace","_notPunctuationOrSpace","punctuation","_punctuationGfmStrongEm","_punctuationOrSpaceGfmStrongEm","_notPunctuationOrSpaceGfmStrongEm","blockSkip","emStrongLDelimCore","emStrongLDelim","emStrongLDelimGfm","emStrongRDelimAstCore","emStrongRDelimAst","emStrongRDelimAstGfm","emStrongRDelimUnd","anyPunctuation","autolink","_inlineComment","tag","_inlineLabel","link","reflink","nolink","reflinkSearch","_caseInsensitiveProtocol","inlineNormal","inlinePedantic","inlineGfm","inlineBreaks","block","inline","escapeReplacements","getEscapeReplacement","ch","encode","cleanUrl","href","splitCells","tableRow","count","row","match","offset","str","escaped","curr","cells","i","rtrim","c","invert","l","suffLen","currChar","findClosingBracket","b","level","outputLink","cap","raw","rules","title","text","token","indentCodeCompensation","matchIndentToCode","indentToCode","node","matchIndentInNode","indentInNode","src","trimmed","lines","tokens","inBlockquote","currentLines","currentRaw","currentText","top","lastToken","oldToken","newText","newToken","isordered","itemRegex","endsWithBlankLine","endEarly","itemContents","line","t","nextLine","blankLine","nextBulletRegex","hrRegex","fencesBeginRegex","headingBeginRegex","htmlBeginRegex","rawLine","nextLineWithoutTabs","istask","ischecked","lastItem","spacers","hasMultipleLineBreaks","headers","aligns","rows","item","align","cell","trimmedUrl","rtrimSlash","lastParenIndex","linkLen","links","linkString","maskedSrc","prevChar","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","lastCharLength","hasNonSpaceChars","hasSpaceCharsOnBothEnds","prevCapZero","__Lexer","next","lastParagraphClipped","extTokenizer","cutSrc","startIndex","tempSrc","tempStart","getStartIndex","errMsg","keepPrevChar","lang","langString","code","depth","ordered","start","body","j","type","startAttr","itemBody","checkbox","checked","header","k","content","cleanHref","out","__Parser","anyToken","genericToken","ret","textToken","renderer","markdown","args","callback","values","tableToken","listToken","childTokens","extensions","pack","opts","ext","prevRenderer","extLevel","prop","rendererProp","rendererFunc","tokenizer","tokenizerProp","tokenizerFunc","prevTokenizer","hooks","hooksProp","hooksFunc","prevHook","arg","packWalktokens","blockType","origOpt","throwError","processedSrc","processedTokens","e","silent","async","msg","markedInstance"],"version":3,"file":"cv.03c3c918.js.map","sourceRoot":"/__parcel_source_root/"}