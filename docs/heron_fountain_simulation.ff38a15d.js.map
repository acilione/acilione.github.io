{"mappings":"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","sources":["<anon>","src/scripts/heron_fountain_simulation.js"],"sourcesContent":["import \"./bubble_simulation.8d2f6bb2.js\";\n\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire0087\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire0087\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $dyjou = parcelRequire(\"dyjou\");\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $9sWXr = parcelRequire(\"9sWXr\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n// =============================================================================\n// PHYSICS IMPLEMENTATION (Revised)\n// =============================================================================\nclass $8482652b5247a78d$var$HeronPhysics {\n    constructor(){\n        // --- Costanti del Modello Fisico (Constants of the Physical Model) ---\n        this.alpha = 1 / 1024; // Unitless ratio\n        this.beta = 1 / 502; // Unitless ratio\n        this.gamma = 1 / 502; // Unitless ratio\n        // Costanti Fisiche (Physical Constants)\n        this.rho = 1000.0; // Density of water [kg/m³]\n        this.g = 9.8; // Acceleration due to gravity [m/s²]\n        this.p_atm = 101325.0; // Atmospheric pressure [Pa]\n        this.wallThickness = 0.2; // Thickness of basin walls [m]\n        // Parametri Geometrici del Sistema (Geometric Parameters of the System)\n        this.S_B = 0.0142; // Cross-sectional area of water surface in Basin B [m²]\n        this.S_C = 0.0142; // Cross-sectional area of water surface in Basin C [m²]\n        // *** BUG 2 FIX ***\n        // The area of A is the sum of B and C\n        this.S_A = this.S_B + this.S_C;\n        this.V_D0 = 0.00355; // Initial volume of air in the air chamber (connecting B and C) [m³]\n        // Livelli di Riferimento Iniziali (Initial Reference Levels)\n        this.h_B0_ref = 0.04; // Initial water height in Basin B [m]\n        this.h_C0_ref = 0.21; // Initial water height in Basin C [m]\n        // Altezze Verticali Fisse (Fixed Vertical Heights)\n        this.h_6 = 0.33; // Height of the nozzle above the bottom reference [m]\n        this.H = 0.25; // Height difference between the surface of Basin A and the top surface of B/C volume [m]\n        // Perdite viscose (Poiseuille) (Viscous Losses)\n        this.eta = 0.001; // Dynamic viscosity of water [Pa·s] or [kg/(m·s)]\n        this.S = 0.0000285; // Cross-sectional area of the narrow internal pipes [m²]\n        this.L1 = 0.22; // Length of the pipe segment (related to flow Q_AB/v2) [m]\n        this.L2 = 0.31; // Length of the pipe segment (related to flow Q_C4/v4) [m]\n        // Viscous resistance coefficient [kg/(m·s)]\n        this.B1 = 8 * Math.PI * this.eta * this.L1 / this.S;\n        this.B2 = 8 * Math.PI * this.eta * this.L2 / this.S;\n        // Initial heights (h_A, h_B, h_C) [m]\n        this.y0 = [\n            0.06,\n            0.04,\n            0.2\n        ];\n        // Tolerance and Guard Parameters\n        this.EPS_DHB = 1e-4; // Epsilon for checking if dhB/dt is near zero [m/s]\n        this.H_EPSILON = 1e-5; // Small tolerance for height check [m]\n        this.T_GUARD = 10.0; // Time guard for stability check [s]\n        // State Variables (Initialised in reset)\n        this.t = 0.0; // Elapsed time [s]\n        this.h_A = 0.0; // Water height in Basin A [m]\n        this.h_B = 0.0; // Water height in Basin B [m]\n        this.h_C = 0.0; // Water height in Basin C [m]\n        this.v2 = 0.0; // Velocity in pipe (A->B) [m/s]\n        this.v4 = 0.0; // Velocity of the water jet (at nozzle 4) [m/s]\n        this.isStable = false; // System stability flag (unitless)\n        // *** NEW ***: Expose p_D for visualizer\n        this.p_D = this.p_atm; // Initial air pressure\n        this.reset();\n    }\n    reset() {\n        [this.h_A, this.h_B, this.h_C] = this.y0;\n        this.t = 0.0;\n        this.v2 = 0.0;\n        this.v4 = 0.0;\n        this.isStable = false;\n        // *** NEW ***: Calculate initial p_D for the visualizer\n        const delta_V_reset = (this.h_B0_ref - this.y0[1]) * this.S_B + (this.h_C0_ref - this.y0[2]) * this.S_C;\n        const V_D = this.V_D0 + delta_V_reset;\n        this.p_D = this.p_atm * this.V_D0 / V_D;\n    }\n    system(h_A, h_B, h_C) {\n        // Change in total air/water volume in B and C relative to initial state [m³]\n        const delta_V = (this.h_B0_ref - h_B) * this.S_B + (this.h_C0_ref - h_C) * this.S_C;\n        // Current volume of air in the air chamber D [m³]\n        const V_D = this.V_D0 + delta_V;\n        // Current pressure in the air chamber D (Boyle's Law: P*V = constant) [Pa]\n        // *** MODIFIED ***: Update class property\n        this.p_D = this.p_atm * this.V_D0 / V_D;\n        // Total pressure head driving flow v2 (A to B) [Pa]\n        const deltaP_AB = this.p_atm - this.p_D + this.rho * this.g * (h_A + this.H - h_B);\n        // Total pressure head driving flow v4 (C to jet) [Pa]\n        const deltaP_C4 = this.p_D - this.p_atm + this.rho * this.g * (h_C - this.h_6);\n        // Velocity v2 (from A to B) - derived from modified Bernoulli/Torricelli with viscous term B1 [m/s]\n        const v2 = (-this.B1 + Math.sqrt(this.B1 ** 2 + 2 * this.rho * Math.max(deltaP_AB, 0.0))) / this.rho;\n        // Velocity v4 (of the jet) - derived from modified Bernoulli/Torricelli with viscous term B2 [m/s]\n        const v4 = (-this.B2 + Math.sqrt(this.B2 ** 2 + 2 * this.rho * Math.max(deltaP_C4, 0.0))) / this.rho;\n        this.v2 = v2;\n        this.v4 = v4;\n        // Change in height over time (Flow rate / Area) [m/s]\n        const dhA_dt = -this.alpha * v2 + this.alpha * v4; // Change in h_A [m/s]\n        const dhB_dt = this.beta * v2; // Change in h_B [m/s]\n        const dhC_dt = -this.gamma * v4; // Change in h_C [m/s]\n        return [\n            dhA_dt,\n            dhB_dt,\n            dhC_dt\n        ];\n    }\n    step(dt) {\n        if (this.isStable) return;\n        // Check if Basin B is empty\n        if (this.h_B < this.H_EPSILON) {\n            this.h_B = 0; // Snap to zero\n            this.isStable = true;\n            this.v2 = 0;\n            this.v4 = 0;\n            return;\n        }\n        const [dhA_dt, dhB_dt, dhC_dt] = this.system(this.h_A, this.h_B, this.h_C);\n        // Check for stability (e.g., flow is near zero)\n        if (this.t > this.T_GUARD && Math.abs(dhB_dt) < this.EPS_DHB) {\n            this.isStable = true;\n            this.v2 = 0;\n            this.v4 = 0;\n            return;\n        }\n        this.h_A += dhA_dt * dt;\n        this.h_B = Math.max(0, this.h_B + dhB_dt * dt);\n        this.h_C += dhC_dt * dt;\n        this.t += dt;\n        this.h_A = Math.max(0, this.h_A);\n        this.h_C = Math.max(0, this.h_C);\n    }\n}\n// =============================================================================\n// THREE.JS SCENE IMPLEMENTATION (MODIFIED)\n// =============================================================================\nclass $8482652b5247a78d$var$HeronFountainScene {\n    constructor(containerId = \"scene-container\"){\n        this.container = document.getElementById(containerId);\n        if (!this.container) throw new Error(`Container element with id '${containerId}' not found.`);\n        // --- *** REVERTED ***: guiParams\n        this.guiParams = {\n            isRunning: false,\n            timeScale: 1.0,\n            viewMode: \"3D\",\n            playPause: ()=>{\n                this.guiParams.isRunning = !this.guiParams.isRunning;\n                this.handlePlayPause();\n            },\n            reset: ()=>{\n                this.resetAll();\n            }\n        };\n        // --- Setup di base ---\n        this.clock = new $dyjou.Clock(false);\n        this.elapsedTime = 0.0;\n        // --- *** REMOVED ***: this.accumulator\n        this.scene = new $dyjou.Scene();\n        this.renderer = new $ilwiq.WebGLRenderer({\n            antialias: true\n        });\n        this.controls = null;\n        this.camera2D = null;\n        this.camera3D = null;\n        this.camera = null;\n        this.h_jet = 0.0;\n        this.currentColors = null; // Initialize the currentColors property\n        // --- *** NEW ***: Theme observer ---\n        this.themeObserver = null;\n        // --- Oggetti di scena ---\n        this.scale = 20; // 1 meter = 20 units in three.js\n        this.physics = new $8482652b5247a78d$var$HeronPhysics();\n        this.waterA = null;\n        this.waterB = null;\n        this.waterC = null;\n        this.waterCascade = null; // Tube mesh\n        this.waterPipe14 = null; // Water mesh inside pipe (A->B)\n        this.waterPipe56 = null; // Water mesh inside pipe (C->Jet)\n        this.pipe56 = null; // Reference to the glass pipe\n        this.cascadeCurve = null; // Curve object\n        this.textOverlay = null;\n        this.textGroups = {};\n        // We will track the mass of each dye (R, G, B) in each basin.\n        this.dyeMassA = {\n            r: 0,\n            g: 0,\n            b: 0\n        };\n        this.dyeMassB = {\n            r: 0,\n            g: 0,\n            b: 0\n        };\n        this.dyeMassC = {\n            r: 0,\n            g: 0,\n            b: 0\n        };\n        // We assume an initial concentration of 1.0 mass unit per volume unit.\n        this.initialConcentration = 1.0;\n        // --- Costanti di layout (scalate) ---\n        this.H_scaled = this.physics.H * this.scale;\n        this.h6_scaled = this.physics.h_6 * this.scale;\n        // Layout sizes\n        this.worldWidth = 0.3 * this.scale;\n        this.worldDepth = 0.1 * this.scale;\n        // --- *** REVERTED *** ---\n        this.internalWallBCH = 0.22 * this.scale;\n        this.topBasinY = this.H_scaled;\n        this.topBasinHeight = 6;\n        // --- Pipe & Jet Radii (Unscaled) ---\n        // Calculate inner radius based on the physics area 'S'\n        this.pipeInnerRadius = Math.sqrt(this.physics.S / Math.PI); // approx 0.00301m (3.01mm)\n        // Add a 1mm wall thickness\n        this.pipeOuterRadius = this.pipeInnerRadius + 0.001; // approx 0.00401m (4.01mm)\n        // The jet's radius is the *inner* radius of the pipe\n        this.jetRadius = this.pipeInnerRadius;\n        // --- *** REMOVED ***: updatePhysicsInitials() call\n        this.initThree();\n        this.setupSceneGeometry();\n        this.setupGUI();\n        this.addTextLabels();\n        this.resetAll(); // resetAll() will now call resetColors()\n        this.animate = this.animate.bind(this);\n        this.animate();\n    }\n    // --- *** REMOVED ***: updatePhysicsInitials() method\n    // --- *** NEW THEME FUNCTIONS *** ---\n    /**\n   * Gets the current theme from the HTML data attribute.\n   * Defaults to 'light'.\n   */ getCurrentTheme() {\n        return document.documentElement.getAttribute(\"data-theme\") === \"dark\" ? \"dark\" : \"light\";\n    }\n    /**\n   * Updates the scene's background color based on the current theme.\n   */ updateSceneTheme() {\n        const theme = this.getCurrentTheme();\n        if (this.scene) // --- *** BUG FIX *** ---\n        // We must ASSIGN a new color, not call .set() on a null property.\n        this.scene.background = new $ilwiq.Color(theme === \"dark\" ? 0x000000 : 0xffffff);\n    }\n    /**\n   * Sets up a MutationObserver to watch for changes to the\n   * `data-theme` attribute on the <html> tag.\n   */ setupThemeObserver() {\n        this.themeObserver = new MutationObserver((mutationsList)=>{\n            for (const mutation of mutationsList)if (mutation.type === \"attributes\" && mutation.attributeName === \"data-theme\") this.updateSceneTheme();\n        });\n        this.themeObserver.observe(document.documentElement, {\n            attributes: true\n        });\n    }\n    initThree() {\n        // --- *** MODIFIED *** ---\n        // Set initial background color based on theme\n        this.updateSceneTheme();\n        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);\n        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n        this.renderer.shadowMap.enabled = true;\n        this.container.appendChild(this.renderer.domElement);\n        const aspect = this.container.clientWidth / this.container.clientHeight;\n        const viewSize = 15;\n        this.camera2D = new $ilwiq.OrthographicCamera(-viewSize * aspect, viewSize * aspect, viewSize, -viewSize, 0.1, 100);\n        this.camera2D.position.set(0, 0, 50);\n        this.camera2D.lookAt(0, this.H_scaled, 0);\n        this.camera3D = new $ilwiq.PerspectiveCamera(50, aspect, 0.1, 200);\n        this.camera3D.position.set(15, 12, 25);\n        this.camera3D.lookAt(0, this.H_scaled, 0);\n        this.camera = this.camera3D;\n        this.controls = new (0, $5Rd1x.OrbitControls)(this.camera3D, this.renderer.domElement);\n        this.controls.enableDamping = true;\n        this.controls.dampingFactor = 0.05;\n        this.controls.target.set(0, this.H_scaled, 0);\n        this.controls.enabled = this.guiParams.viewMode === \"3D\";\n        const ambientLight = new $dyjou.AmbientLight(0xffffff, 0.7);\n        this.scene.add(ambientLight);\n        const directionalLight = new $dyjou.DirectionalLight(0xffffff, 1.0);\n        directionalLight.position.set(10, 20, 15);\n        directionalLight.castShadow = true;\n        this.scene.add(directionalLight);\n        window.addEventListener(\"resize\", this.onWindowResize.bind(this));\n        // --- Auto-pause to prevent \"time bomb\" ---\n        window.addEventListener(\"blur\", ()=>{\n            if (this.guiParams.isRunning) this.guiParams.playPause(); // This toggles isRunning and stops the clock\n        });\n        // --- *** NEW ***: Start listening for theme changes ---\n        this.setupThemeObserver();\n    }\n    setupSceneGeometry() {\n        const waterMaterial = new $dyjou.MeshPhysicalMaterial({\n            transmission: 0.9,\n            thickness: 1.5 * this.scale,\n            roughness: 0.1,\n            ior: 1.33,\n            transparent: true,\n            opacity: 0.7,\n            side: $ilwiq.DoubleSide,\n            depthWrite: true\n        });\n        const glassMaterial = new $dyjou.MeshPhysicalMaterial({\n            color: 0xffffff,\n            transmission: 0.95,\n            thickness: 0.5,\n            roughness: 0.05,\n            ior: 1.52,\n            transparent: true,\n            opacity: 0.6,\n            side: $ilwiq.DoubleSide,\n            depthWrite: false\n        });\n        const basinWidth = this.worldWidth / 2;\n        const basinDepth = this.worldDepth;\n        const waterAMaterial = new $dyjou.MeshPhysicalMaterial({\n            ...waterMaterial\n        });\n        const waterBMaterial = new $dyjou.MeshPhysicalMaterial({\n            ...waterMaterial\n        });\n        const waterCMaterial = new $dyjou.MeshPhysicalMaterial({\n            ...waterMaterial\n        });\n        // Water boxes\n        const waterGeom = new $ilwiq.BoxGeometry(1, 1, 1);\n        this.waterA = new $ilwiq.Mesh(waterGeom, waterAMaterial);\n        this.waterA.scale.set(this.worldWidth, 1, basinDepth);\n        this.waterA.renderOrder = 2;\n        this.scene.add(this.waterA);\n        this.waterB = new $ilwiq.Mesh(waterGeom, waterBMaterial);\n        this.waterB.scale.set(basinWidth, 1, basinDepth);\n        this.waterB.position.x = -basinWidth / 2;\n        this.waterB.renderOrder = 2;\n        this.scene.add(this.waterB);\n        this.waterC = new $ilwiq.Mesh(waterGeom, waterCMaterial);\n        this.waterC.scale.set(basinWidth, 1, basinDepth);\n        this.waterC.position.x = basinWidth / 2;\n        this.waterC.renderOrder = 2;\n        this.scene.add(this.waterC);\n        // Walls (glass)\n        const wallThickness = this.physics.wallThickness;\n        const createWall = (w, h, d, x, y, z)=>{\n            const geom = new $ilwiq.BoxGeometry(w, h, d);\n            const mesh = new $ilwiq.Mesh(geom, glassMaterial.clone()); // Use clone\n            mesh.position.set(x, y, z);\n            mesh.renderOrder = 1;\n            this.scene.add(mesh);\n            return mesh;\n        };\n        createWall(this.worldWidth + wallThickness * 2, wallThickness, basinDepth + wallThickness * 2, 0, -wallThickness / 2, 0);\n        createWall(this.worldWidth + wallThickness * 2, wallThickness, basinDepth + wallThickness * 2, 0, this.H_scaled, 0);\n        createWall(this.worldWidth + wallThickness * 2, wallThickness, basinDepth + wallThickness * 2, 0, this.topBasinY + this.topBasinHeight, 0);\n        const totalHeight = this.topBasinY + this.topBasinHeight;\n        createWall(wallThickness, totalHeight, basinDepth + wallThickness, -this.worldWidth / 2 - wallThickness / 2, totalHeight / 2 - wallThickness / 2, 0);\n        createWall(wallThickness, totalHeight, basinDepth + wallThickness, this.worldWidth / 2 + wallThickness / 2, totalHeight / 2 - wallThickness / 2, 0);\n        createWall(this.worldWidth + wallThickness * 2, totalHeight, wallThickness, 0, totalHeight / 2 - wallThickness / 2, -basinDepth / 2 - wallThickness / 2);\n        createWall(this.worldWidth + wallThickness * 2, totalHeight, wallThickness, 0, totalHeight / 2 - wallThickness / 2, basinDepth / 2 + wallThickness / 2);\n        // Internal divider\n        createWall(wallThickness, this.internalWallBCH, basinDepth, 0, this.internalWallBCH / 2, 0);\n        // Pipes (MODIFIED for hollow appearance)\n        const s = this.scale;\n        const innerR_scaled = this.pipeInnerRadius * s;\n        const outerR_scaled = this.pipeOuterRadius * s;\n        /**\n     * Helper function to create a thick-walled hollow pipe\n     * using THREE.ExtrudeGeometry.\n     */ const createHollowPipe = (outerR, innerR, height, x, y_center, z)=>{\n            // 1. Create the Annulus (ring) shape\n            const shape = new $dyjou.Shape();\n            shape.absarc(0, 0, outerR, 0, Math.PI * 2, false); // Outer circle\n            const hole = new $dyjou.Path();\n            hole.absarc(0, 0, innerR, 0, Math.PI * 2, true); // Inner circle (hole)\n            shape.holes.push(hole);\n            // 2. Define extrusion settings\n            const extrudeSettings = {\n                depth: height,\n                bevelEnabled: false\n            };\n            // 3. Create the geometry\n            const geom = new $dyjou.ExtrudeGeometry(shape, extrudeSettings);\n            // 4. Create the mesh\n            const mesh = new $ilwiq.Mesh(geom, glassMaterial.clone()); // Use transparent glass\n            // 5. Orient and position the mesh\n            // ExtrudeGeometry builds along the Z-axis. We rotate it to stand along the Y-axis.\n            mesh.rotation.x = Math.PI / 2;\n            // The CylinderGeometry's position 'y' was its center.\n            // The Extruded geometry (after rotation) runs from y=0 to y=height.\n            // We set its position so its center matches the original y_center.\n            mesh.position.set(x, y_center + height / 2, z);\n            mesh.renderOrder = 1;\n            this.scene.add(mesh);\n            return mesh;\n        };\n        // Tubo 1-4 (A -> B)\n        createHollowPipe(outerR_scaled, innerR_scaled, this.H_scaled, -basinWidth / 2, this.H_scaled / 2, 0 // z\n        );\n        // Tubo 5-6 (C -> A -> Jet)\n        this.pipe56 = createHollowPipe(outerR_scaled, innerR_scaled, this.h6_scaled, basinWidth / 2, this.h6_scaled / 2, 0 // z\n        );\n        // --- Water inside the pipes ---\n        // Water for Tube 1-4 (A -> B)\n        const waterPipeGeom1 = new $dyjou.CylinderGeometry(innerR_scaled, innerR_scaled, this.H_scaled, 16);\n        this.waterPipe14 = new $ilwiq.Mesh(waterPipeGeom1, waterMaterial.clone());\n        this.waterPipe14.position.set(-basinWidth / 2, this.H_scaled / 2, 0);\n        this.waterPipe14.visible = false;\n        this.waterPipe14.renderOrder = 2;\n        this.scene.add(this.waterPipe14);\n        // Water for Tube 5-6 (C -> Jet)\n        const waterPipeGeom2 = new $dyjou.CylinderGeometry(innerR_scaled, innerR_scaled, this.h6_scaled, 16);\n        this.waterPipe56 = new $ilwiq.Mesh(waterPipeGeom2, waterMaterial.clone());\n        this.waterPipe56.position.set(basinWidth / 2, this.h6_scaled / 2, 0);\n        this.waterPipe56.visible = false;\n        this.waterPipe56.renderOrder = 2;\n        this.scene.add(this.waterPipe56);\n        // --- Curved water jet using TubeGeometry ---\n        const cascadeMaterial = new $dyjou.MeshPhysicalMaterial({\n            color: 0x40a0ff,\n            transmission: 0.7,\n            thickness: 0.1 * this.scale,\n            roughness: 0.3,\n            ior: 1.33,\n            transparent: true,\n            opacity: 1,\n            side: $ilwiq.DoubleSide,\n            depthWrite: false\n        });\n        // Initialize with a dummy curve\n        // this.jetRadius is now unscaled inner radius. We scale it for the geometry.\n        const path = new $dyjou.LineCurve3(new $ilwiq.Vector3(0, 0, 0), new $ilwiq.Vector3(1, 1, 1));\n        const tubeGeometry = new $dyjou.TubeGeometry(path, 20, this.jetRadius * s, 8, false);\n        this.waterCascade = new $ilwiq.Mesh(tubeGeometry, cascadeMaterial);\n        this.waterCascade.visible = false; // Initially hidden\n        this.waterCascade.renderOrder = 3;\n        this.scene.add(this.waterCascade);\n    }\n    // --- *** REVERTED ***: setupGUI\n    setupGUI() {\n        const gui = new (0, $9sWXr.default)({\n            title: \"Heron's Fountain Controls\"\n        });\n        gui.add(this.guiParams, \"playPause\").name(\"\\u25B6\\uFE0F / \\u23F8\\uFE0F Start/Pause\");\n        gui.add(this.guiParams, \"reset\").name(\"\\uD83D\\uDD04 Reset All\");\n        gui.add(this.guiParams, \"timeScale\", 0.1, 5.0, 0.1).name(\"Time Scale\");\n        gui.add(this.guiParams, \"viewMode\", [\n            \"2D\",\n            \"3D\"\n        ]).name(\"View Mode\").onChange((value)=>{\n            this.camera = value === \"2D\" ? this.camera2D : this.camera3D;\n            this.controls.enabled = value === \"3D\";\n            this.onWindowResize();\n        });\n    }\n    // --- *** REVERTED ***: resetColors\n    resetColors() {\n        // Get initial volumes from the physics model\n        const volA0 = this.physics.y0[0] * this.physics.S_A; // h_A * S_A\n        const volB0 = this.physics.y0[1] * this.physics.S_B; // h_B * S_B\n        const volC0 = this.physics.y0[2] * this.physics.S_C; // h_C * S_C\n        // Set initial dye mass based on volume and concentration\n        this.dyeMassA = {\n            r: volA0 * this.initialConcentration,\n            g: 0,\n            b: 0\n        };\n        this.dyeMassB = {\n            r: 0,\n            g: volB0 * this.initialConcentration,\n            b: 0\n        };\n        this.dyeMassC = {\n            r: 0,\n            g: 0,\n            b: volC0 * this.initialConcentration\n        };\n        // Apply the initial visual colors (for frame 0)\n        // We use a subtractive (pigment) model: 1.0 - (other colors)\n        if (this.waterA) this.waterA.material.color.setRGB(1, 0, 0); // Red\n        if (this.waterB) this.waterB.material.color.setRGB(0, 1, 0); // Green\n        if (this.waterC) this.waterC.material.color.setRGB(0, 0, 1); // Blue\n        if (this.waterCascade) this.waterCascade.material.color.setRGB(0, 0, 1);\n    }\n    // --- *** REVERTED ***: resetAll\n    resetAll() {\n        this.guiParams.isRunning = false;\n        this.clock.stop();\n        this.elapsedTime = 0.0;\n        // --- *** REMOVED ***: this.accumulator\n        this.physics.reset(); // This now uses the default y0 values\n        this.h_jet = 0.0;\n        this.resetColors(); // This now uses the default y0 values\n        this.updateWaterMeshes();\n        // Reset the water cascade\n        this.waterCascade.visible = false;\n        // Hide water in pipes (will be set by updatePipeWaterLevels)\n        if (this.waterPipe14) this.waterPipe14.visible = false;\n        if (this.waterPipe56) this.waterPipe56.visible = false;\n        this.updateTextLabels();\n        // --- Manually update colors one last time after reset ---\n        this.updateWaterColors(0.0);\n    }\n    handlePlayPause() {\n        if (this.guiParams.isRunning) {\n            if (this.physics.isStable) this.resetAll();\n            this.guiParams.isRunning = true;\n            this.clock.start();\n        } else this.clock.stop();\n    }\n    updateWaterMeshes() {\n        const { h_A: h_A, h_B: h_B, h_C: h_C } = this.physics;\n        const s = this.scale;\n        const hA_s = Math.max(0.01, h_A * s);\n        const hB_s = Math.max(0.01, h_B * s);\n        this.waterB.visible = h_B > 0; // Hide mesh if empty\n        const hC_s = Math.max(0.01, h_C * s);\n        this.waterA.scale.y = hA_s;\n        this.waterA.position.y = this.H_scaled + hA_s / 2;\n        this.waterB.scale.y = hB_s;\n        this.waterB.position.y = hB_s / 2;\n        this.waterC.scale.y = hC_s;\n        this.waterC.position.y = hC_s / 2;\n    }\n    /**\n   * Vertical jet\n   */ updateCascade(dt) {\n        // Hide immediately if stable\n        if (this.physics.isStable) {\n            this.waterCascade.visible = false;\n            return;\n        }\n        // We use the actual unscaled velocity (m/s) for calculating the trajectory\n        const v4 = Math.max(0, this.physics.v4);\n        // Set a minimum threshold for visibility\n        if (v4 < 0.1 || !this.guiParams.isRunning) {\n            this.waterCascade.visible = false;\n            return;\n        }\n        this.waterCascade.visible = true;\n        // --- Scaled Position Constants ---\n        const s = this.scale;\n        const G = this.physics.g; // Unscaled gravity\n        // The ExtrudeGeometry's X/Z position is correct\n        const nozzleX = this.pipe56.position.x;\n        const nozzleZ = this.pipe56.position.z;\n        // The nozzle Y is the top of the pipe\n        const nozzleY = this.h6_scaled;\n        const waterATopY = this.waterA.position.y + this.waterA.scale.y / 2;\n        // --- Trajectory Parameters ---\n        // Set angle to be almost vertical (e.g., 85 degrees) to match image\n        const angleRad = Math.PI * 85 / 180;\n        // Unscaled velocity components\n        const v_y0 = v4 * Math.sin(angleRad); // High vertical velocity\n        const v_x0 = v4 * Math.cos(angleRad); // Low horizontal velocity\n        // --- Calculate Time of Flight (T) and Landing Position ---\n        // Target landing Y is the water surface in Basin A\n        const finalY_target = waterATopY - 0.5 * this.jetRadius * s;\n        // Quadratic equation coefficients (scaled)\n        const a = 0.5 * G * s;\n        const b = -v_y0 * s;\n        const c = finalY_target - nozzleY;\n        const discriminant = b * b - 4 * a * c;\n        let timeToFall = 0;\n        if (discriminant >= 0) timeToFall = (-b + Math.sqrt(discriminant)) / (2 * a);\n        timeToFall = isNaN(timeToFall) ? 0.2 : Math.max(0.1, timeToFall);\n        // Calculate final position (scaled coordinates)\n        const horizontalOffset = -v_x0 * timeToFall * s;\n        const endX = nozzleX + horizontalOffset;\n        const endY = finalY_target;\n        const endZ = nozzleZ;\n        // --- Define the Curved Path (Cubic Bezier Curve) ---\n        const p0 = new $ilwiq.Vector3(nozzleX, nozzleY, nozzleZ);\n        const p3 = new $ilwiq.Vector3(endX, endY, endZ);\n        // 1. Calculate Apex Position (Scaled)\n        const t_apex = v_y0 / G; // Time to reach max height (unscaled)\n        const apexY = nozzleY + v_y0 * t_apex * s - 0.5 * G * t_apex * t_apex * s;\n        const apexX = nozzleX + horizontalOffset / 2.0;\n        const actualApexY = Math.max(apexY, nozzleY);\n        // 2. Control Point 1 (P1):\n        const p1 = new $ilwiq.Vector3(p0.x + (p3.x - p0.x) * (1 / 3), actualApexY, p0.z);\n        // 3. Control Point 2 (P2):\n        const p2 = new $ilwiq.Vector3(p0.x + (p3.x - p0.x) * (2 / 3), actualApexY, p3.z);\n        // Create the new curve\n        this.cascadeCurve = new $dyjou.CubicBezierCurve3(p0, p1, p2, p3);\n        // --- Update Tube Geometry ---\n        if (this.waterCascade.geometry) this.waterCascade.geometry.dispose();\n        const segments = 30;\n        // Create new Tube Geometry\n        this.waterCascade.geometry = new $dyjou.TubeGeometry(this.cascadeCurve, segments, this.jetRadius * s, 8, false);\n        // Update h_jet for the display\n        const jetHeightMeters = v_y0 * v_y0 / (2 * G);\n        this.h_jet = jetHeightMeters;\n    }\n    updateWaterColors(dt) {\n        if (dt <= 0) return; // Do not run if time is not advancing\n        const epsilon = 1e-6; // Prevent division by zero\n        // --- 1. Get current volumes from physics ---\n        const volA = this.physics.h_A * this.physics.S_A + epsilon;\n        const volB = this.physics.h_B * this.physics.S_B + epsilon;\n        const volC = this.physics.h_C * this.physics.S_C + epsilon;\n        // --- 2. Get volumetric flow rates (m³/s) and flow volumes (m³) ---\n        // Q_C4 = (dhC/dt) * S_C = (gamma * v4) * S_C\n        const flowVolume_CA = this.physics.gamma * this.physics.v4 * this.physics.S_C * dt;\n        // Q_AB = (dhB/dt) * S_B = (beta * v2) * S_B\n        const flowVolume_AB = this.physics.beta * this.physics.v2 * this.physics.S_B * dt;\n        // --- 3. Mass Transfer: C -> A (Jet) ---\n        if (flowVolume_CA > 0 && this.physics.v4 > 0.01) {\n            // Find concentration (mass/volume) in C\n            const concR_C = this.dyeMassC.r / volC;\n            const concG_C = this.dyeMassC.g / volC;\n            const concB_C = this.dyeMassC.b / volC;\n            // Find mass transferred (concentration * flow_volume)\n            const massR_flow = concR_C * flowVolume_CA;\n            const massG_flow = concG_C * flowVolume_CA;\n            const massB_flow = concB_C * flowVolume_CA;\n            // Update masses in A and C\n            this.dyeMassA.r += massR_flow;\n            this.dyeMassA.g += massG_flow;\n            this.dyeMassA.b += massB_flow;\n            this.dyeMassC.r = Math.max(0, this.dyeMassC.r - massR_flow);\n            this.dyeMassC.g = Math.max(0, this.dyeMassC.g - massG_flow);\n            this.dyeMassC.b = Math.max(0, this.dyeMassC.b - massB_flow);\n        }\n        // --- 4. Mass Transfer: A -> B (Pipe) ---\n        if (flowVolume_AB > 0 && this.physics.v2 > 0.01) {\n            // Find concentration (mass/volume) in A\n            const concR_A = this.dyeMassA.r / volA;\n            const concG_A = this.dyeMassA.g / volA;\n            const concB_A = this.dyeMassA.b / volA;\n            // Find mass transferred (concentration * flow_volume)\n            const massR_flow = concR_A * flowVolume_AB;\n            const massG_flow = concG_A * flowVolume_AB;\n            const massB_flow = concB_A * flowVolume_AB;\n            // Update masses in B and A\n            this.dyeMassB.r += massR_flow;\n            this.dyeMassB.g += massG_flow;\n            this.dyeMassB.b += massB_flow;\n            this.dyeMassA.r = Math.max(0, this.dyeMassA.r - massR_flow);\n            this.dyeMassA.g = Math.max(0, this.dyeMassA.g - massG_flow);\n            this.dyeMassA.b = Math.max(0, this.dyeMassA.b - massB_flow);\n        }\n        // --- 5. Apply Visual Colors (Subtractive Pigment Model) ---\n        // This model correctly mixes R+B=Purple and R+G+B=Brown/Black.\n        // Clamp concentration (0.0 to 1.0) for the color model\n        const clamp = (val)=>Math.max(0, Math.min(val, 1.0));\n        // Calculate concentrations in A\n        const cR_A = clamp(this.dyeMassA.r / volA / this.initialConcentration);\n        const cG_A = clamp(this.dyeMassA.g / volA / this.initialConcentration);\n        const cB_A = clamp(this.dyeMassA.b / volA / this.initialConcentration);\n        // Calculate concentrations in B\n        const cR_B = clamp(this.dyeMassB.r / volB / this.initialConcentration);\n        const cG_B = clamp(this.dyeMassB.g / volB / this.initialConcentration);\n        const cB_B = clamp(this.dyeMassB.b / volB / this.initialConcentration);\n        // Calculate concentrations in C\n        const cR_C = clamp(this.dyeMassC.r / volC / this.initialConcentration);\n        const cG_C = clamp(this.dyeMassC.g / volC / this.initialConcentration);\n        const cB_C = clamp(this.dyeMassC.b / volC / this.initialConcentration);\n        // Apply subtractive mixing: Color = 1.0 - (other pigments)\n        this.waterA.material.color.setRGB(clamp(1.0 - cG_A - cB_A), clamp(1.0 - cR_A - cB_A), clamp(1.0 - cR_A - cG_A));\n        this.waterB.material.color.setRGB(clamp(1.0 - cG_B - cB_B), clamp(1.0 - cR_B - cB_B), clamp(1.0 - cR_B - cG_B));\n        this.waterC.material.color.setRGB(clamp(1.0 - cG_C - cB_C), clamp(1.0 - cR_C - cB_C), clamp(1.0 - cR_C - cG_C));\n        // Jet, Pipe 1-4, and Pipe 5-6 take the color of their source basin\n        this.waterCascade.material.color.copy(this.waterC.material.color);\n        this.waterPipe56.material.color.copy(this.waterC.material.color);\n        this.waterPipe14.material.color.copy(this.waterA.material.color);\n    }\n    /**\n   * *** NEW METHOD ***\n   * Updates the visual water level inside the pipes based on physics.\n   */ updatePipeWaterLevels() {\n        const s = this.scale;\n        // Only show pipe water if running and not stable\n        const isRunning = this.guiParams.isRunning && !this.physics.isStable;\n        const h_min_scaled = 0.01 * s; // Minimum visible height\n        // --- Pipe 1-4 (A -> B) ---\n        // This pipe represents water falling from Basin A (at y=H) down to the\n        // water level of Basin B (at y=h_B).\n        const h_A_unscaled = this.physics.h_A;\n        const h_B_unscaled = this.physics.h_B;\n        const H_unscaled = this.physics.H; // Top of pipe\n        // The water column in the pipe exists between the top of the pipe (H)\n        // and the water level in Basin B (h_B).\n        let waterHeight_unscaled = Math.max(0, H_unscaled - h_B_unscaled);\n        let waterHeight_scaled = waterHeight_unscaled * s;\n        // The Y-position of the *bottom* of this water column is h_B\n        let waterBottom_scaled = h_B_unscaled * s;\n        // The Y-position of the *center* of this water column\n        let waterCenter_scaled = waterBottom_scaled + waterHeight_scaled / 2;\n        // We only show this water if:\n        // 1. The simulation is running.\n        // 2. There is actually water falling (v2 > 0.01).\n        // 3. There is water in Basin A to fall from (h_A > 0).\n        // 4. The pipe isn't 'full' (h_B < H).\n        if (isRunning && this.physics.v2 > 0.01 && h_A_unscaled > 0 && waterHeight_scaled > h_min_scaled) {\n            this.waterPipe14.visible = true;\n            // The original geometry was H_scaled tall.\n            // We must scale its Y-axis to match the new calculated height.\n            // (new_height / original_height)\n            this.waterPipe14.scale.y = Math.max(0.001, waterHeight_scaled / this.H_scaled);\n            // We must also move its position to the new center.\n            this.waterPipe14.position.y = waterCenter_scaled;\n        } else this.waterPipe14.visible = false;\n        // --- Pipe 5-6 (C -> Jet) ---\n        // This pipe's water level rises based on air pressure p_D.\n        const { p_D: p_D, rho: rho, g: g, h_C: h_C, h_6: h_6, p_atm: p_atm } = this.physics;\n        // Calculate the static height the water *would* reach in the pipe (unscaled)\n        // h_pipe = (Pressure_Diff / (rho*g)) + source_height\n        let h_pipe_unscaled = (p_D - p_atm) / (rho * g) + h_C;\n        // Clamp 1: Water level in pipe can't be *lower* than the source (Basin C)\n        h_pipe_unscaled = Math.max(h_C, h_pipe_unscaled);\n        // Clamp 2: Water level can't be *higher* than the physical pipe's end (nozzle)\n        h_pipe_unscaled = Math.min(h_pipe_unscaled, h_6);\n        // Clamp 3: Water level can't be negative\n        h_pipe_unscaled = Math.max(0, h_pipe_unscaled);\n        const h_pipe_scaled = h_pipe_unscaled * s;\n        if (h_pipe_scaled > h_min_scaled && isRunning) {\n            this.waterPipe56.visible = true;\n            // The geometry for waterPipe56 was created with height h6_scaled\n            // We must scale its Y-axis to match the new calculated height\n            this.waterPipe56.scale.y = Math.max(0.001, h_pipe_scaled / this.h6_scaled);\n            // We must also move its position, as the center of the\n            // cylinder is now at (h_pipe_scaled / 2)\n            this.waterPipe56.position.y = h_pipe_scaled / 2;\n        } else this.waterPipe56.visible = false;\n    }\n    // --- UI & helpers (Unchanged) ---\n    addTextLabels() {\n        if (this.textOverlay) this.textOverlay.remove();\n        this.textOverlay = document.createElement(\"div\");\n        this.textOverlay.className = \"text-label-overlay\";\n        this.container.appendChild(this.textOverlay);\n        const createLabel = (id)=>{\n            const div = document.createElement(\"div\");\n            div.className = \"label-group\";\n            div.id = id;\n            this.textOverlay.appendChild(div);\n            return div;\n        };\n        this.textGroups.A = createLabel(\"label-A\");\n        this.textGroups.B = createLabel(\"label-B\");\n        this.textGroups.C = createLabel(\"label-C\");\n        this.textGroups.Time = createLabel(\"label-Time\");\n        this.textGroups.Jet = createLabel(\"label-Jet\");\n    }\n    toScreenPosition(vector3, camera, canvas) {\n        const width = canvas.clientWidth;\n        const height = canvas.clientHeight;\n        const vector = vector3.clone().project(camera);\n        vector.x = (vector.x + 1) / 2 * width;\n        vector.y = -(vector.y - 1) / 2 * height;\n        return {\n            x: vector.x,\n            y: vector.y\n        };\n    }\n    updateTextLabels() {\n        if (!this.textGroups.A) return;\n        const s = this.scale;\n        const canvas = this.renderer.domElement;\n        const posA = new $ilwiq.Vector3(0, this.H_scaled + this.topBasinHeight - 1, 0);\n        const posB = new $ilwiq.Vector3(-this.worldWidth / 4, this.H_scaled - 1, 0);\n        const posC = new $ilwiq.Vector3(this.worldWidth / 4, this.H_scaled - 1, 0);\n        const posJet = new $ilwiq.Vector3(this.worldWidth / 4, this.h6_scaled + 2, 0);\n        const screenPosA = this.toScreenPosition(posA, this.camera, canvas);\n        this.textGroups.A.style.left = `${screenPosA.x}px`;\n        this.textGroups.A.style.top = `${screenPosA.y}px`;\n        this.textGroups.A.innerHTML = `\n                <div>Basin A</div>\n                <div>h_A: ${(this.physics.h_A * 100).toFixed(1)} cm</div>\n                `;\n        const screenPosB = this.toScreenPosition(posB, this.camera, canvas);\n        this.textGroups.B.style.left = `${screenPosB.x}px`;\n        this.textGroups.B.style.top = `${screenPosB.y}px`;\n        this.textGroups.B.innerHTML = `\n                <div>Basin B</div>\n                <div>h_B: ${(this.physics.h_B * 100).toFixed(1)} cm</div>\n                `;\n        const screenPosC = this.toScreenPosition(posC, this.camera, canvas);\n        this.textGroups.C.style.left = `${screenPosC.x}px`;\n        this.textGroups.C.style.top = `${screenPosC.y}px`;\n        this.textGroups.C.innerHTML = `\n                <div>Basin C</div>\n                <div>h_C: ${(this.physics.h_C * 100).toFixed(1)} cm</div>\n                `;\n        const screenPosJet = this.toScreenPosition(posJet, this.camera, canvas);\n        this.textGroups.Jet.style.left = `${screenPosJet.x}px`;\n        this.textGroups.Jet.style.top = `${screenPosJet.y}px`;\n        this.textGroups.Jet.innerHTML = `\n                <div>Jet</div>\n                <div>v_4: ${this.physics.v4.toFixed(2)} m/s</div>\n                <div>h_jet: ${(this.h_jet * 100).toFixed(1)} cm</div>\n                `;\n        this.textGroups.Time.style.left = `50%`;\n        this.textGroups.Time.style.top = `20px`;\n        const status = this.physics.isStable ? \"STABLE (B empty)\" : this.guiParams.isRunning ? \"RUNNING\" : \"PAUSED\";\n        this.textGroups.Time.innerHTML = `\n                <div>Time: ${this.physics.t.toFixed(2)} s</div>\n                <div>State: ${status}</div>\n                `;\n    }\n    onWindowResize() {\n        const aspect = this.container.clientWidth / this.container.clientHeight;\n        const viewSize = 15;\n        this.camera2D.left = -viewSize * aspect;\n        this.camera2D.right = viewSize * aspect;\n        this.camera2D.top = viewSize;\n        this.camera2D.bottom = -viewSize;\n        this.camera2D.updateProjectionMatrix();\n        this.camera3D.aspect = aspect;\n        this.camera3D.updateProjectionMatrix();\n        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);\n    }\n    // --- *** REVERTED ***: animate()\n    animate() {\n        requestAnimationFrame(this.animate);\n        if (this.guiParams.viewMode === \"3D\") this.controls.update();\n        if (this.guiParams.isRunning) {\n            // Get the real time delta, uncapped\n            const delta = this.clock.getDelta() * this.guiParams.timeScale;\n            this.elapsedTime += delta;\n            if (!this.physics.isStable) {\n                this.physics.step(delta);\n                this.updateWaterMeshes();\n                this.updateWaterColors(delta);\n            } else {\n                // If stable, stop running the simulation automatically\n                this.guiParams.isRunning = false;\n                this.clock.stop();\n            }\n            this.updateCascade(delta); // Use the new curve update\n        } else // Even when paused, allow the cascade to hide\n        this.updateCascade(0.0);\n        // *** NEW ***: Call this every frame\n        this.updatePipeWaterLevels();\n        this.updateTextLabels();\n        this.renderer.render(this.scene, this.camera);\n    }\n}\n// Initialize when DOM ready\ndocument.addEventListener(\"DOMContentLoaded\", ()=>{\n    try {\n        new $8482652b5247a78d$var$HeronFountainScene(\"scene-container\");\n    } catch (e) {\n        console.error(\"Impossibile inizializzare la scena:\", e);\n        document.GetElementById(\"scene-container\").innerHTML = \"<h3>Errore durante l'inizializzazione della simulazione.</h3><pre>\" + e.stack + \"</pre>\";\n    }\n});\n\n\n//# sourceMappingURL=heron_fountain_simulation.ff38a15d.js.map\n","import * as THREE from \"three\";\nimport GUI from \"lil-gui\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls.js\";\n\n// =============================================================================\n// PHYSICS IMPLEMENTATION (Revised)\n// =============================================================================\n\nclass HeronPhysics {\n  constructor() {\n    // --- Costanti del Modello Fisico (Constants of the Physical Model) ---\n    this.alpha = 1 / 1024; // Unitless ratio\n    this.beta = 1 / 502; // Unitless ratio\n    this.gamma = 1 / 502; // Unitless ratio\n\n    // Costanti Fisiche (Physical Constants)\n    this.rho = 1000.0; // Density of water [kg/m³]\n    this.g = 9.8; // Acceleration due to gravity [m/s²]\n    this.p_atm = 101325.0; // Atmospheric pressure [Pa]\n\n    this.wallThickness = 0.2; // Thickness of basin walls [m]\n    // Parametri Geometrici del Sistema (Geometric Parameters of the System)\n    this.S_B = 0.0142; // Cross-sectional area of water surface in Basin B [m²]\n    this.S_C = 0.0142; // Cross-sectional area of water surface in Basin C [m²]\n\n    // *** BUG 2 FIX ***\n    // The area of A is the sum of B and C\n    this.S_A = this.S_B + this.S_C;\n\n    this.V_D0 = 0.00355; // Initial volume of air in the air chamber (connecting B and C) [m³]\n\n    // Livelli di Riferimento Iniziali (Initial Reference Levels)\n    this.h_B0_ref = 0.04; // Initial water height in Basin B [m]\n    this.h_C0_ref = 0.21; // Initial water height in Basin C [m]\n\n    // Altezze Verticali Fisse (Fixed Vertical Heights)\n    this.h_6 = 0.33; // Height of the nozzle above the bottom reference [m]\n    this.H = 0.25; // Height difference between the surface of Basin A and the top surface of B/C volume [m]\n\n    // Perdite viscose (Poiseuille) (Viscous Losses)\n    this.eta = 0.001; // Dynamic viscosity of water [Pa·s] or [kg/(m·s)]\n    this.S = 0.0000285; // Cross-sectional area of the narrow internal pipes [m²]\n    this.L1 = 0.22; // Length of the pipe segment (related to flow Q_AB/v2) [m]\n    this.L2 = 0.31; // Length of the pipe segment (related to flow Q_C4/v4) [m]\n\n    // Viscous resistance coefficient [kg/(m·s)]\n    this.B1 = (8 * Math.PI * this.eta * this.L1) / this.S;\n    this.B2 = (8 * Math.PI * this.eta * this.L2) / this.S;\n\n    // Initial heights (h_A, h_B, h_C) [m]\n    this.y0 = [0.06, 0.04, 0.2];\n\n    // Tolerance and Guard Parameters\n    this.EPS_DHB = 1e-4; // Epsilon for checking if dhB/dt is near zero [m/s]\n    this.H_EPSILON = 1e-5; // Small tolerance for height check [m]\n    this.T_GUARD = 10.0; // Time guard for stability check [s]\n\n    // State Variables (Initialised in reset)\n    this.t = 0.0; // Elapsed time [s]\n    this.h_A = 0.0; // Water height in Basin A [m]\n    this.h_B = 0.0; // Water height in Basin B [m]\n    this.h_C = 0.0; // Water height in Basin C [m]\n    this.v2 = 0.0; // Velocity in pipe (A->B) [m/s]\n    this.v4 = 0.0; // Velocity of the water jet (at nozzle 4) [m/s]\n    this.isStable = false; // System stability flag (unitless)\n\n    // *** NEW ***: Expose p_D for visualizer\n    this.p_D = this.p_atm; // Initial air pressure\n\n    this.reset();\n  }\n\n  reset() {\n    [this.h_A, this.h_B, this.h_C] = this.y0;\n    this.t = 0.0;\n    this.v2 = 0.0;\n    this.v4 = 0.0;\n    this.isStable = false;\n\n    // *** NEW ***: Calculate initial p_D for the visualizer\n    const delta_V_reset =\n      (this.h_B0_ref - this.y0[1]) * this.S_B +\n      (this.h_C0_ref - this.y0[2]) * this.S_C;\n    const V_D = this.V_D0 + delta_V_reset;\n    this.p_D = (this.p_atm * this.V_D0) / V_D;\n  }\n\n  system(h_A, h_B, h_C) {\n    // Change in total air/water volume in B and C relative to initial state [m³]\n    const delta_V =\n      (this.h_B0_ref - h_B) * this.S_B + (this.h_C0_ref - h_C) * this.S_C;\n    // Current volume of air in the air chamber D [m³]\n    const V_D = this.V_D0 + delta_V;\n    // Current pressure in the air chamber D (Boyle's Law: P*V = constant) [Pa]\n\n    // *** MODIFIED ***: Update class property\n    this.p_D = (this.p_atm * this.V_D0) / V_D;\n\n    // Total pressure head driving flow v2 (A to B) [Pa]\n    const deltaP_AB =\n      this.p_atm - this.p_D + this.rho * this.g * (h_A + this.H - h_B);\n    // Total pressure head driving flow v4 (C to jet) [Pa]\n    const deltaP_C4 = this.p_D - this.p_atm + this.rho * this.g * (h_C - this.h_6);\n\n    // Velocity v2 (from A to B) - derived from modified Bernoulli/Torricelli with viscous term B1 [m/s]\n    const v2 =\n      (-this.B1 +\n        Math.sqrt(this.B1 ** 2 + 2 * this.rho * Math.max(deltaP_AB, 0.0))) /\n      this.rho;\n    // Velocity v4 (of the jet) - derived from modified Bernoulli/Torricelli with viscous term B2 [m/s]\n    const v4 =\n      (-this.B2 +\n        Math.sqrt(this.B2 ** 2 + 2 * this.rho * Math.max(deltaP_C4, 0.0))) /\n      this.rho;\n\n    this.v2 = v2;\n    this.v4 = v4;\n\n    // Change in height over time (Flow rate / Area) [m/s]\n    const dhA_dt = -this.alpha * v2 + this.alpha * v4; // Change in h_A [m/s]\n    const dhB_dt = this.beta * v2; // Change in h_B [m/s]\n    const dhC_dt = -this.gamma * v4; // Change in h_C [m/s]\n\n    return [dhA_dt, dhB_dt, dhC_dt];\n  }\n\n  step(dt) {\n    if (this.isStable) return;\n\n    // Check if Basin B is empty\n    if (this.h_B < this.H_EPSILON) {\n      this.h_B = 0; // Snap to zero\n      this.isStable = true;\n      this.v2 = 0;\n      this.v4 = 0;\n      return;\n    }\n\n    const [dhA_dt, dhB_dt, dhC_dt] = this.system(this.h_A, this.h_B, this.h_C);\n\n    // Check for stability (e.g., flow is near zero)\n    if (this.t > this.T_GUARD && Math.abs(dhB_dt) < this.EPS_DHB) {\n      this.isStable = true;\n      this.v2 = 0;\n      this.v4 = 0;\n      return;\n    }\n\n    this.h_A += dhA_dt * dt;\n    this.h_B = Math.max(0, this.h_B + dhB_dt * dt);\n    this.h_C += dhC_dt * dt;\n    this.t += dt;\n\n    this.h_A = Math.max(0, this.h_A);\n    this.h_C = Math.max(0, this.h_C);\n  }\n}\n\n// =============================================================================\n// THREE.JS SCENE IMPLEMENTATION (MODIFIED)\n// =============================================================================\n\nclass HeronFountainScene {\n  constructor(containerId = \"scene-container\") {\n    this.container = document.getElementById(containerId);\n    if (!this.container)\n      throw new Error(`Container element with id '${containerId}' not found.`);\n\n    // --- *** REVERTED ***: guiParams\n    this.guiParams = {\n      isRunning: false,\n      timeScale: 1.0,\n      viewMode: \"3D\",\n      playPause: () => {\n        this.guiParams.isRunning = !this.guiParams.isRunning;\n        this.handlePlayPause();\n      },\n      reset: () => {\n        this.resetAll();\n      },\n    };\n\n    // --- Setup di base ---\n    this.clock = new THREE.Clock(false);\n    this.elapsedTime = 0.0;\n    // --- *** REMOVED ***: this.accumulator\n    this.scene = new THREE.Scene();\n    this.renderer = new THREE.WebGLRenderer({ antialias: true });\n    this.controls = null;\n    this.camera2D = null;\n    this.camera3D = null;\n    this.camera = null;\n    this.h_jet = 0.0;\n    this.currentColors = null; // Initialize the currentColors property\n\n    // --- *** NEW ***: Theme observer ---\n    this.themeObserver = null;\n\n    // --- Oggetti di scena ---\n    this.scale = 20; // 1 meter = 20 units in three.js\n    this.physics = new HeronPhysics();\n    this.waterA = null;\n    this.waterB = null;\n    this.waterC = null;\n    this.waterCascade = null; // Tube mesh\n    this.waterPipe14 = null; // Water mesh inside pipe (A->B)\n    this.waterPipe56 = null; // Water mesh inside pipe (C->Jet)\n    this.pipe56 = null; // Reference to the glass pipe\n    this.cascadeCurve = null; // Curve object\n    this.textOverlay = null;\n    this.textGroups = {};\n\n    // We will track the mass of each dye (R, G, B) in each basin.\n    this.dyeMassA = { r: 0, g: 0, b: 0 };\n    this.dyeMassB = { r: 0, g: 0, b: 0 };\n    this.dyeMassC = { r: 0, g: 0, b: 0 };\n    // We assume an initial concentration of 1.0 mass unit per volume unit.\n    this.initialConcentration = 1.0;\n\n    // --- Costanti di layout (scalate) ---\n    this.H_scaled = this.physics.H * this.scale;\n    this.h6_scaled = this.physics.h_6 * this.scale;\n\n    // Layout sizes\n    this.worldWidth = 0.3 * this.scale;\n    this.worldDepth = 0.1 * this.scale;\n    // --- *** REVERTED *** ---\n    this.internalWallBCH = 0.22 * this.scale;\n    this.topBasinY = this.H_scaled;\n    this.topBasinHeight = 6;\n\n    // --- Pipe & Jet Radii (Unscaled) ---\n    // Calculate inner radius based on the physics area 'S'\n    this.pipeInnerRadius = Math.sqrt(this.physics.S / Math.PI); // approx 0.00301m (3.01mm)\n    // Add a 1mm wall thickness\n    this.pipeOuterRadius = this.pipeInnerRadius + 0.001; // approx 0.00401m (4.01mm)\n    // The jet's radius is the *inner* radius of the pipe\n    this.jetRadius = this.pipeInnerRadius;\n    \n    // --- *** REMOVED ***: updatePhysicsInitials() call\n\n    this.initThree();\n    this.setupSceneGeometry();\n    this.setupGUI();\n    this.addTextLabels();\n    this.resetAll(); // resetAll() will now call resetColors()\n\n    this.animate = this.animate.bind(this);\n    this.animate();\n  }\n\n  // --- *** REMOVED ***: updatePhysicsInitials() method\n\n  // --- *** NEW THEME FUNCTIONS *** ---\n  /**\n   * Gets the current theme from the HTML data attribute.\n   * Defaults to 'light'.\n   */\n  getCurrentTheme() {\n    return document.documentElement.getAttribute(\"data-theme\") === \"dark\"\n      ? \"dark\"\n      : \"light\";\n  }\n\n  /**\n   * Updates the scene's background color based on the current theme.\n   */\n  updateSceneTheme() {\n    const theme = this.getCurrentTheme();\n    if (this.scene) {\n      // --- *** BUG FIX *** ---\n      // We must ASSIGN a new color, not call .set() on a null property.\n      this.scene.background = new THREE.Color(\n        theme === \"dark\" ? 0x000000 : 0xffffff\n      );\n    }\n  }\n\n  /**\n   * Sets up a MutationObserver to watch for changes to the\n   * `data-theme` attribute on the <html> tag.\n   */\n  setupThemeObserver() {\n    this.themeObserver = new MutationObserver((mutationsList) => {\n      for (const mutation of mutationsList) {\n        if (\n          mutation.type === \"attributes\" &&\n          mutation.attributeName === \"data-theme\"\n        ) {\n          this.updateSceneTheme();\n        }\n      }\n    });\n\n    this.themeObserver.observe(document.documentElement, { attributes: true });\n  }\n\n  initThree() {\n    // --- *** MODIFIED *** ---\n    // Set initial background color based on theme\n    this.updateSceneTheme();\n\n    this.renderer.setSize(\n      this.container.clientWidth,\n      this.container.clientHeight\n    );\n    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    this.renderer.shadowMap.enabled = true;\n    this.container.appendChild(this.renderer.domElement);\n\n    const aspect = this.container.clientWidth / this.container.clientHeight;\n    const viewSize = 15;\n\n    this.camera2D = new THREE.OrthographicCamera(\n      -viewSize * aspect,\n      viewSize * aspect,\n      viewSize,\n      -viewSize,\n      0.1,\n      100\n    );\n    this.camera2D.position.set(0, 0, 50);\n    this.camera2D.lookAt(0, this.H_scaled, 0);\n\n    this.camera3D = new THREE.PerspectiveCamera(50, aspect, 0.1, 200);\n    this.camera3D.position.set(15, 12, 25);\n    this.camera3D.lookAt(0, this.H_scaled, 0);\n\n    this.camera = this.camera3D;\n\n    this.controls = new OrbitControls(this.camera3D, this.renderer.domElement);\n    this.controls.enableDamping = true;\n    this.controls.dampingFactor = 0.05;\n    this.controls.target.set(0, this.H_scaled, 0);\n    this.controls.enabled = this.guiParams.viewMode === \"3D\";\n\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);\n    this.scene.add(ambientLight);\n\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);\n    directionalLight.position.set(10, 20, 15);\n    directionalLight.castShadow = true;\n    this.scene.add(directionalLight);\n\n    window.addEventListener(\"resize\", this.onWindowResize.bind(this));\n\n    // --- Auto-pause to prevent \"time bomb\" ---\n    window.addEventListener(\"blur\", () => {\n      if (this.guiParams.isRunning) {\n        this.guiParams.playPause(); // This toggles isRunning and stops the clock\n      }\n    });\n\n    // --- *** NEW ***: Start listening for theme changes ---\n    this.setupThemeObserver();\n  }\n\n  setupSceneGeometry() {\n    const waterMaterial = new THREE.MeshPhysicalMaterial({\n      transmission: 0.9,\n      thickness: 1.5 * this.scale,\n      roughness: 0.1,\n      ior: 1.33,\n      transparent: true,\n      opacity: 0.7,\n      side: THREE.DoubleSide,\n      depthWrite: true,\n    });\n\n    const glassMaterial = new THREE.MeshPhysicalMaterial({\n      color: 0xffffff,\n      transmission: 0.95,\n      thickness: 0.5,\n      roughness: 0.05,\n      ior: 1.52,\n      transparent: true,\n      opacity: 0.6,\n      side: THREE.DoubleSide,\n      depthWrite: false,\n    });\n\n    const basinWidth = this.worldWidth / 2;\n    const basinDepth = this.worldDepth;\n\n    const waterAMaterial = new THREE.MeshPhysicalMaterial({ ...waterMaterial });\n    const waterBMaterial = new THREE.MeshPhysicalMaterial({ ...waterMaterial });\n    const waterCMaterial = new THREE.MeshPhysicalMaterial({ ...waterMaterial });\n\n    // Water boxes\n    const waterGeom = new THREE.BoxGeometry(1, 1, 1);\n    this.waterA = new THREE.Mesh(waterGeom, waterAMaterial);\n    this.waterA.scale.set(this.worldWidth, 1, basinDepth);\n\n    this.waterA.renderOrder = 2;\n    this.scene.add(this.waterA);\n\n    this.waterB = new THREE.Mesh(waterGeom, waterBMaterial);\n    this.waterB.scale.set(basinWidth, 1, basinDepth);\n    this.waterB.position.x = -basinWidth / 2;\n\n    this.waterB.renderOrder = 2;\n\n    this.scene.add(this.waterB);\n\n    this.waterC = new THREE.Mesh(waterGeom, waterCMaterial);\n    this.waterC.scale.set(basinWidth, 1, basinDepth);\n    this.waterC.position.x = basinWidth / 2;\n\n    this.waterC.renderOrder = 2;\n    this.scene.add(this.waterC);\n\n    // Walls (glass)\n    const wallThickness = this.physics.wallThickness;\n    const createWall = (w, h, d, x, y, z) => {\n      const geom = new THREE.BoxGeometry(w, h, d);\n      const mesh = new THREE.Mesh(geom, glassMaterial.clone()); // Use clone\n      mesh.position.set(x, y, z);\n\n      mesh.renderOrder = 1;\n\n      this.scene.add(mesh);\n\n      return mesh;\n    };\n\n    createWall(\n      this.worldWidth + wallThickness * 2,\n      wallThickness,\n      basinDepth + wallThickness * 2,\n      0,\n      -wallThickness / 2,\n      0\n    );\n    createWall(\n      this.worldWidth + wallThickness * 2,\n      wallThickness,\n      basinDepth + wallThickness * 2,\n      0,\n      this.H_scaled,\n      0\n    );\n    createWall(\n      this.worldWidth + wallThickness * 2,\n      wallThickness,\n      basinDepth + wallThickness * 2,\n      0,\n      this.topBasinY + this.topBasinHeight,\n      0\n    );\n\n    const totalHeight = this.topBasinY + this.topBasinHeight;\n    createWall(\n      wallThickness,\n      totalHeight,\n      basinDepth + wallThickness,\n      -this.worldWidth / 2 - wallThickness / 2,\n      totalHeight / 2 - wallThickness / 2,\n      0\n    );\n    createWall(\n      wallThickness,\n      totalHeight,\n      basinDepth + wallThickness,\n      this.worldWidth / 2 + wallThickness / 2,\n      totalHeight / 2 - wallThickness / 2,\n      0\n    );\n    createWall(\n      this.worldWidth + wallThickness * 2,\n      totalHeight,\n      wallThickness,\n      0,\n      totalHeight / 2 - wallThickness / 2,\n      -basinDepth / 2 - wallThickness / 2\n    );\n    createWall(\n      this.worldWidth + wallThickness * 2,\n      totalHeight,\n      wallThickness,\n      0,\n      totalHeight / 2 - wallThickness / 2,\n      basinDepth / 2 + wallThickness / 2\n    );\n\n    // Internal divider\n    createWall(\n      wallThickness,\n      this.internalWallBCH, // Use scaled value\n      basinDepth,\n      0,\n      this.internalWallBCH / 2,\n      0\n    );\n\n    // Pipes (MODIFIED for hollow appearance)\n    const s = this.scale;\n    const innerR_scaled = this.pipeInnerRadius * s;\n    const outerR_scaled = this.pipeOuterRadius * s;\n\n    /**\n     * Helper function to create a thick-walled hollow pipe\n     * using THREE.ExtrudeGeometry.\n     */\n    const createHollowPipe = (outerR, innerR, height, x, y_center, z) => {\n      // 1. Create the Annulus (ring) shape\n      const shape = new THREE.Shape();\n      shape.absarc(0, 0, outerR, 0, Math.PI * 2, false); // Outer circle\n      const hole = new THREE.Path();\n      hole.absarc(0, 0, innerR, 0, Math.PI * 2, true); // Inner circle (hole)\n      shape.holes.push(hole);\n\n      // 2. Define extrusion settings\n      const extrudeSettings = {\n        depth: height, // The length of the pipe\n        bevelEnabled: false,\n      };\n\n      // 3. Create the geometry\n      const geom = new THREE.ExtrudeGeometry(shape, extrudeSettings);\n\n      // 4. Create the mesh\n      const mesh = new THREE.Mesh(geom, glassMaterial.clone()); // Use transparent glass\n\n      // 5. Orient and position the mesh\n      // ExtrudeGeometry builds along the Z-axis. We rotate it to stand along the Y-axis.\n      mesh.rotation.x = Math.PI / 2;\n\n      // The CylinderGeometry's position 'y' was its center.\n      // The Extruded geometry (after rotation) runs from y=0 to y=height.\n      // We set its position so its center matches the original y_center.\n      mesh.position.set(x, y_center + height / 2, z);\n\n      mesh.renderOrder = 1;\n      this.scene.add(mesh);\n\n      return mesh;\n    };\n\n    // Tubo 1-4 (A -> B)\n    createHollowPipe(\n      outerR_scaled,\n      innerR_scaled,\n      this.H_scaled, // height\n      -basinWidth / 2, // x\n      this.H_scaled / 2, // y_center\n      0 // z\n    );\n\n    // Tubo 5-6 (C -> A -> Jet)\n    this.pipe56 = createHollowPipe(\n      outerR_scaled,\n      innerR_scaled,\n      this.h6_scaled, // height\n      basinWidth / 2, // x\n      this.h6_scaled / 2, // y_center\n      0 // z\n    );\n\n    // --- Water inside the pipes ---\n\n    // Water for Tube 1-4 (A -> B)\n    const waterPipeGeom1 = new THREE.CylinderGeometry(\n      innerR_scaled,\n      innerR_scaled,\n      this.H_scaled, // NOTE: This is the *original* height\n      16\n    );\n    this.waterPipe14 = new THREE.Mesh(waterPipeGeom1, waterMaterial.clone());\n    this.waterPipe14.position.set(-basinWidth / 2, this.H_scaled / 2, 0);\n    this.waterPipe14.visible = false;\n\n    this.waterPipe14.renderOrder = 2;\n    this.scene.add(this.waterPipe14);\n\n    // Water for Tube 5-6 (C -> Jet)\n    const waterPipeGeom2 = new THREE.CylinderGeometry(\n      innerR_scaled,\n      innerR_scaled,\n      this.h6_scaled, // NOTE: This is the *original* height\n      16\n    );\n    this.waterPipe56 = new THREE.Mesh(waterPipeGeom2, waterMaterial.clone());\n    this.waterPipe56.position.set(basinWidth / 2, this.h6_scaled / 2, 0);\n    this.waterPipe56.visible = false;\n\n    this.waterPipe56.renderOrder = 2;\n    this.scene.add(this.waterPipe56);\n\n    // --- Curved water jet using TubeGeometry ---\n    const cascadeMaterial = new THREE.MeshPhysicalMaterial({\n      color: 0x40a0ff,\n      transmission: 0.7,\n      thickness: 0.1 * this.scale,\n      roughness: 0.3,\n      ior: 1.33,\n      transparent: true,\n      opacity: 1,\n      side: THREE.DoubleSide,\n      depthWrite: false,\n    });\n\n    // Initialize with a dummy curve\n    // this.jetRadius is now unscaled inner radius. We scale it for the geometry.\n    const path = new THREE.LineCurve3(\n      new THREE.Vector3(0, 0, 0),\n      new THREE.Vector3(1, 1, 1)\n    );\n    const tubeGeometry = new THREE.TubeGeometry(\n      path,\n      20,\n      this.jetRadius * s,\n      8,\n      false\n    );\n\n    this.waterCascade = new THREE.Mesh(tubeGeometry, cascadeMaterial);\n    this.waterCascade.visible = false; // Initially hidden\n\n    this.waterCascade.renderOrder = 3;\n    this.scene.add(this.waterCascade);\n  }\n\n  // --- *** REVERTED ***: setupGUI\n  setupGUI() {\n    const gui = new GUI({ title: \"Heron's Fountain Controls\" });\n    gui.add(this.guiParams, \"playPause\").name(\"▶️ / ⏸️ Start/Pause\");\n    gui.add(this.guiParams, \"reset\").name(\"🔄 Reset All\");\n    gui.add(this.guiParams, \"timeScale\", 0.1, 5.0, 0.1).name(\"Time Scale\");\n    gui\n      .add(this.guiParams, \"viewMode\", [\"2D\", \"3D\"])\n      .name(\"View Mode\")\n      .onChange((value) => {\n        this.camera = value === \"2D\" ? this.camera2D : this.camera3D;\n        this.controls.enabled = value === \"3D\";\n        this.onWindowResize();\n      });\n  }\n\n  // --- *** REVERTED ***: resetColors\n  resetColors() {\n    // Get initial volumes from the physics model\n    const volA0 = this.physics.y0[0] * this.physics.S_A; // h_A * S_A\n    const volB0 = this.physics.y0[1] * this.physics.S_B; // h_B * S_B\n    const volC0 = this.physics.y0[2] * this.physics.S_C; // h_C * S_C\n\n    // Set initial dye mass based on volume and concentration\n    this.dyeMassA = {\n      r: volA0 * this.initialConcentration,\n      g: 0,\n      b: 0,\n    };\n    this.dyeMassB = {\n      r: 0,\n      g: volB0 * this.initialConcentration,\n      b: 0,\n    };\n    this.dyeMassC = {\n      r: 0,\n      g: 0,\n      b: volC0 * this.initialConcentration,\n    };\n\n    // Apply the initial visual colors (for frame 0)\n    // We use a subtractive (pigment) model: 1.0 - (other colors)\n    if (this.waterA) this.waterA.material.color.setRGB(1, 0, 0); // Red\n    if (this.waterB) this.waterB.material.color.setRGB(0, 1, 0); // Green\n    if (this.waterC) this.waterC.material.color.setRGB(0, 0, 1); // Blue\n    if (this.waterCascade) this.waterCascade.material.color.setRGB(0, 0, 1);\n  }\n\n  // --- *** REVERTED ***: resetAll\n  resetAll() {\n    this.guiParams.isRunning = false;\n    this.clock.stop();\n    this.elapsedTime = 0.0;\n    // --- *** REMOVED ***: this.accumulator\n    this.physics.reset(); // This now uses the default y0 values\n    this.h_jet = 0.0;\n\n    this.resetColors(); // This now uses the default y0 values\n\n    this.updateWaterMeshes();\n\n    // Reset the water cascade\n    this.waterCascade.visible = false;\n\n    // Hide water in pipes (will be set by updatePipeWaterLevels)\n    if (this.waterPipe14) this.waterPipe14.visible = false;\n    if (this.waterPipe56) this.waterPipe56.visible = false;\n\n    this.updateTextLabels();\n\n    // --- Manually update colors one last time after reset ---\n    this.updateWaterColors(0.0);\n  }\n\n  handlePlayPause() {\n    if (this.guiParams.isRunning) {\n      if (this.physics.isStable) {\n        this.resetAll();\n      }\n      this.guiParams.isRunning = true;\n      this.clock.start();\n    } else {\n      this.clock.stop();\n    }\n  }\n\n  updateWaterMeshes() {\n    const { h_A, h_B, h_C } = this.physics;\n    const s = this.scale;\n\n    const hA_s = Math.max(0.01, h_A * s);\n    const hB_s = Math.max(0.01, h_B * s);\n    this.waterB.visible = h_B > 0; // Hide mesh if empty\n\n    const hC_s = Math.max(0.01, h_C * s);\n\n    this.waterA.scale.y = hA_s;\n    this.waterA.position.y = this.H_scaled + hA_s / 2;\n\n    this.waterB.scale.y = hB_s;\n    this.waterB.position.y = hB_s / 2;\n\n    this.waterC.scale.y = hC_s;\n    this.waterC.position.y = hC_s / 2;\n  }\n\n  /**\n   * Vertical jet\n   */\n  updateCascade(dt) {\n    // Hide immediately if stable\n    if (this.physics.isStable) {\n      this.waterCascade.visible = false;\n      return;\n    }\n\n    // We use the actual unscaled velocity (m/s) for calculating the trajectory\n    const v4 = Math.max(0, this.physics.v4);\n\n    // Set a minimum threshold for visibility\n    if (v4 < 0.1 || !this.guiParams.isRunning) {\n      this.waterCascade.visible = false;\n      return;\n    }\n\n    this.waterCascade.visible = true;\n\n    // --- Scaled Position Constants ---\n    const s = this.scale;\n    const G = this.physics.g; // Unscaled gravity\n\n    // The ExtrudeGeometry's X/Z position is correct\n    const nozzleX = this.pipe56.position.x;\n    const nozzleZ = this.pipe56.position.z;\n    // The nozzle Y is the top of the pipe\n    const nozzleY = this.h6_scaled;\n\n    const waterATopY = this.waterA.position.y + this.waterA.scale.y / 2;\n\n    // --- Trajectory Parameters ---\n\n    // Set angle to be almost vertical (e.g., 85 degrees) to match image\n    const angleRad = (Math.PI * 85) / 180;\n\n    // Unscaled velocity components\n    const v_y0 = v4 * Math.sin(angleRad); // High vertical velocity\n    const v_x0 = v4 * Math.cos(angleRad); // Low horizontal velocity\n\n    // --- Calculate Time of Flight (T) and Landing Position ---\n\n    // Target landing Y is the water surface in Basin A\n    const finalY_target = waterATopY - 0.5 * this.jetRadius * s;\n\n    // Quadratic equation coefficients (scaled)\n    const a = 0.5 * G * s;\n    const b = -v_y0 * s;\n    const c = finalY_target - nozzleY;\n\n    const discriminant = b * b - 4 * a * c;\n\n    let timeToFall = 0;\n    if (discriminant >= 0) {\n      timeToFall = (-b + Math.sqrt(discriminant)) / (2 * a);\n    }\n\n    timeToFall = isNaN(timeToFall) ? 0.2 : Math.max(0.1, timeToFall);\n\n    // Calculate final position (scaled coordinates)\n    const horizontalOffset = -v_x0 * timeToFall * s;\n    const endX = nozzleX + horizontalOffset;\n    const endY = finalY_target;\n    const endZ = nozzleZ;\n\n    // --- Define the Curved Path (Cubic Bezier Curve) ---\n\n    const p0 = new THREE.Vector3(nozzleX, nozzleY, nozzleZ);\n    const p3 = new THREE.Vector3(endX, endY, endZ);\n\n    // 1. Calculate Apex Position (Scaled)\n    const t_apex = v_y0 / G; // Time to reach max height (unscaled)\n    const apexY = nozzleY + v_y0 * t_apex * s - 0.5 * G * t_apex * t_apex * s;\n    const apexX = nozzleX + horizontalOffset / 2.0;\n\n    const actualApexY = Math.max(apexY, nozzleY);\n\n    // 2. Control Point 1 (P1):\n    const p1 = new THREE.Vector3(\n      p0.x + (p3.x - p0.x) * (1 / 3),\n      actualApexY, // Force control point to height of apex\n      p0.z\n    );\n\n    // 3. Control Point 2 (P2):\n    const p2 = new THREE.Vector3(\n      p0.x + (p3.x - p0.x) * (2 / 3),\n      actualApexY, // Force control point to height of apex\n      p3.z\n    );\n\n    // Create the new curve\n    this.cascadeCurve = new THREE.CubicBezierCurve3(p0, p1, p2, p3);\n\n    // --- Update Tube Geometry ---\n    if (this.waterCascade.geometry) {\n      this.waterCascade.geometry.dispose();\n    }\n\n    const segments = 30;\n\n    // Create new Tube Geometry\n    this.waterCascade.geometry = new THREE.TubeGeometry(\n      this.cascadeCurve,\n      segments,\n      this.jetRadius * s, // Use scaled inner radius\n      8,\n      false\n    );\n\n    // Update h_jet for the display\n    const jetHeightMeters = (v_y0 * v_y0) / (2 * G);\n    this.h_jet = jetHeightMeters;\n  }\n\n  updateWaterColors(dt) {\n    if (dt <= 0) return; // Do not run if time is not advancing\n\n    const epsilon = 1e-6; // Prevent division by zero\n\n    // --- 1. Get current volumes from physics ---\n    const volA = this.physics.h_A * this.physics.S_A + epsilon;\n    const volB = this.physics.h_B * this.physics.S_B + epsilon;\n    const volC = this.physics.h_C * this.physics.S_C + epsilon;\n\n    // --- 2. Get volumetric flow rates (m³/s) and flow volumes (m³) ---\n    // Q_C4 = (dhC/dt) * S_C = (gamma * v4) * S_C\n    const flowVolume_CA =\n      this.physics.gamma * this.physics.v4 * this.physics.S_C * dt;\n    // Q_AB = (dhB/dt) * S_B = (beta * v2) * S_B\n    const flowVolume_AB =\n      this.physics.beta * this.physics.v2 * this.physics.S_B * dt;\n\n    // --- 3. Mass Transfer: C -> A (Jet) ---\n    if (flowVolume_CA > 0 && this.physics.v4 > 0.01) {\n      // Find concentration (mass/volume) in C\n      const concR_C = this.dyeMassC.r / volC;\n      const concG_C = this.dyeMassC.g / volC;\n      const concB_C = this.dyeMassC.b / volC;\n\n      // Find mass transferred (concentration * flow_volume)\n      const massR_flow = concR_C * flowVolume_CA;\n      const massG_flow = concG_C * flowVolume_CA;\n      const massB_flow = concB_C * flowVolume_CA;\n\n      // Update masses in A and C\n      this.dyeMassA.r += massR_flow;\n      this.dyeMassA.g += massG_flow;\n      this.dyeMassA.b += massB_flow;\n\n      this.dyeMassC.r = Math.max(0, this.dyeMassC.r - massR_flow);\n      this.dyeMassC.g = Math.max(0, this.dyeMassC.g - massG_flow);\n      this.dyeMassC.b = Math.max(0, this.dyeMassC.b - massB_flow);\n    }\n\n    // --- 4. Mass Transfer: A -> B (Pipe) ---\n    if (flowVolume_AB > 0 && this.physics.v2 > 0.01) {\n      // Find concentration (mass/volume) in A\n      const concR_A = this.dyeMassA.r / volA;\n      const concG_A = this.dyeMassA.g / volA;\n      const concB_A = this.dyeMassA.b / volA;\n\n      // Find mass transferred (concentration * flow_volume)\n      const massR_flow = concR_A * flowVolume_AB;\n      const massG_flow = concG_A * flowVolume_AB;\n      const massB_flow = concB_A * flowVolume_AB;\n\n      // Update masses in B and A\n      this.dyeMassB.r += massR_flow;\n      this.dyeMassB.g += massG_flow;\n      this.dyeMassB.b += massB_flow;\n\n      this.dyeMassA.r = Math.max(0, this.dyeMassA.r - massR_flow);\n      this.dyeMassA.g = Math.max(0, this.dyeMassA.g - massG_flow);\n      this.dyeMassA.b = Math.max(0, this.dyeMassA.b - massB_flow);\n    }\n\n    // --- 5. Apply Visual Colors (Subtractive Pigment Model) ---\n    // This model correctly mixes R+B=Purple and R+G+B=Brown/Black.\n\n    // Clamp concentration (0.0 to 1.0) for the color model\n    const clamp = (val) => Math.max(0, Math.min(val, 1.0));\n\n    // Calculate concentrations in A\n    const cR_A = clamp(this.dyeMassA.r / volA / this.initialConcentration);\n    const cG_A = clamp(this.dyeMassA.g / volA / this.initialConcentration);\n    const cB_A = clamp(this.dyeMassA.b / volA / this.initialConcentration);\n\n    // Calculate concentrations in B\n    const cR_B = clamp(this.dyeMassB.r / volB / this.initialConcentration);\n    const cG_B = clamp(this.dyeMassB.g / volB / this.initialConcentration);\n    const cB_B = clamp(this.dyeMassB.b / volB / this.initialConcentration);\n\n    // Calculate concentrations in C\n    const cR_C = clamp(this.dyeMassC.r / volC / this.initialConcentration);\n    const cG_C = clamp(this.dyeMassC.g / volC / this.initialConcentration);\n    const cB_C = clamp(this.dyeMassC.b / volC / this.initialConcentration);\n\n    // Apply subtractive mixing: Color = 1.0 - (other pigments)\n    this.waterA.material.color.setRGB(\n      clamp(1.0 - cG_A - cB_A),\n      clamp(1.0 - cR_A - cB_A),\n      clamp(1.0 - cR_A - cG_A)\n    );\n\n    this.waterB.material.color.setRGB(\n      clamp(1.0 - cG_B - cB_B),\n      clamp(1.0 - cR_B - cB_B),\n      clamp(1.0 - cR_B - cG_B)\n    );\n\n    this.waterC.material.color.setRGB(\n      clamp(1.0 - cG_C - cB_C),\n      clamp(1.0 - cR_C - cB_C),\n      clamp(1.0 - cR_C - cG_C)\n    );\n\n    // Jet, Pipe 1-4, and Pipe 5-6 take the color of their source basin\n    this.waterCascade.material.color.copy(this.waterC.material.color);\n    this.waterPipe56.material.color.copy(this.waterC.material.color);\n    this.waterPipe14.material.color.copy(this.waterA.material.color);\n  }\n\n  /**\n   * *** NEW METHOD ***\n   * Updates the visual water level inside the pipes based on physics.\n   */\n  updatePipeWaterLevels() {\n    const s = this.scale;\n    // Only show pipe water if running and not stable\n    const isRunning = this.guiParams.isRunning && !this.physics.isStable;\n    const h_min_scaled = 0.01 * s; // Minimum visible height\n\n    // --- Pipe 1-4 (A -> B) ---\n    // This pipe represents water falling from Basin A (at y=H) down to the\n    // water level of Basin B (at y=h_B).\n    const h_A_unscaled = this.physics.h_A;\n    const h_B_unscaled = this.physics.h_B;\n    const H_unscaled = this.physics.H; // Top of pipe\n\n    // The water column in the pipe exists between the top of the pipe (H)\n    // and the water level in Basin B (h_B).\n    let waterHeight_unscaled = Math.max(0, H_unscaled - h_B_unscaled);\n    let waterHeight_scaled = waterHeight_unscaled * s;\n\n    // The Y-position of the *bottom* of this water column is h_B\n    let waterBottom_scaled = h_B_unscaled * s;\n\n    // The Y-position of the *center* of this water column\n    let waterCenter_scaled = waterBottom_scaled + waterHeight_scaled / 2;\n\n    // We only show this water if:\n    // 1. The simulation is running.\n    // 2. There is actually water falling (v2 > 0.01).\n    // 3. There is water in Basin A to fall from (h_A > 0).\n    // 4. The pipe isn't 'full' (h_B < H).\n    if (\n      isRunning &&\n      this.physics.v2 > 0.01 &&\n      h_A_unscaled > 0 &&\n      waterHeight_scaled > h_min_scaled\n    ) {\n      this.waterPipe14.visible = true;\n\n      // The original geometry was H_scaled tall.\n      // We must scale its Y-axis to match the new calculated height.\n      // (new_height / original_height)\n      this.waterPipe14.scale.y = Math.max(\n        0.001,\n        waterHeight_scaled / this.H_scaled\n      );\n\n      // We must also move its position to the new center.\n      this.waterPipe14.position.y = waterCenter_scaled;\n    } else {\n      this.waterPipe14.visible = false;\n    }\n\n    // --- Pipe 5-6 (C -> Jet) ---\n    // This pipe's water level rises based on air pressure p_D.\n    const { p_D, rho, g, h_C, h_6, p_atm } = this.physics;\n\n    // Calculate the static height the water *would* reach in the pipe (unscaled)\n    // h_pipe = (Pressure_Diff / (rho*g)) + source_height\n    let h_pipe_unscaled = (p_D - p_atm) / (rho * g) + h_C;\n\n    // Clamp 1: Water level in pipe can't be *lower* than the source (Basin C)\n    h_pipe_unscaled = Math.max(h_C, h_pipe_unscaled);\n    // Clamp 2: Water level can't be *higher* than the physical pipe's end (nozzle)\n    h_pipe_unscaled = Math.min(h_pipe_unscaled, h_6);\n    // Clamp 3: Water level can't be negative\n    h_pipe_unscaled = Math.max(0, h_pipe_unscaled);\n\n    const h_pipe_scaled = h_pipe_unscaled * s;\n\n    if (h_pipe_scaled > h_min_scaled && isRunning) {\n      this.waterPipe56.visible = true;\n\n      // The geometry for waterPipe56 was created with height h6_scaled\n      // We must scale its Y-axis to match the new calculated height\n      this.waterPipe56.scale.y = Math.max(\n        0.001,\n        h_pipe_scaled / this.h6_scaled\n      );\n\n      // We must also move its position, as the center of the\n      // cylinder is now at (h_pipe_scaled / 2)\n      this.waterPipe56.position.y = h_pipe_scaled / 2;\n    } else {\n      this.waterPipe56.visible = false;\n    }\n  }\n\n  // --- UI & helpers (Unchanged) ---\n\n  addTextLabels() {\n    if (this.textOverlay) this.textOverlay.remove();\n\n    this.textOverlay = document.createElement(\"div\");\n    this.textOverlay.className = \"text-label-overlay\";\n    this.container.appendChild(this.textOverlay);\n\n    const createLabel = (id) => {\n      const div = document.createElement(\"div\");\n      div.className = \"label-group\";\n      div.id = id;\n      this.textOverlay.appendChild(div);\n      return div;\n    };\n\n    this.textGroups.A = createLabel(\"label-A\");\n    this.textGroups.B = createLabel(\"label-B\");\n    this.textGroups.C = createLabel(\"label-C\");\n    this.textGroups.Time = createLabel(\"label-Time\");\n    this.textGroups.Jet = createLabel(\"label-Jet\");\n  }\n\n  toScreenPosition(vector3, camera, canvas) {\n    const width = canvas.clientWidth;\n    const height = canvas.clientHeight;\n    const vector = vector3.clone().project(camera);\n    vector.x = ((vector.x + 1) / 2) * width;\n    vector.y = (-(vector.y - 1) / 2) * height;\n    return { x: vector.x, y: vector.y };\n  }\n\n  updateTextLabels() {\n    if (!this.textGroups.A) return;\n\n    const s = this.scale;\n    const canvas = this.renderer.domElement;\n\n    const posA = new THREE.Vector3(\n      0,\n      this.H_scaled + this.topBasinHeight - 1,\n      0\n    );\n    const posB = new THREE.Vector3(-this.worldWidth / 4, this.H_scaled - 1, 0);\n    const posC = new THREE.Vector3(this.worldWidth / 4, this.H_scaled - 1, 0);\n    const posJet = new THREE.Vector3(\n      this.worldWidth / 4,\n      this.h6_scaled + 2,\n      0\n    );\n\n    const screenPosA = this.toScreenPosition(posA, this.camera, canvas);\n    this.textGroups.A.style.left = `${screenPosA.x}px`;\n    this.textGroups.A.style.top = `${screenPosA.y}px`;\n    this.textGroups.A.innerHTML = `\n                <div>Basin A</div>\n                <div>h_A: ${(this.physics.h_A * 100).toFixed(1)} cm</div>\n                `;\n\n    const screenPosB = this.toScreenPosition(posB, this.camera, canvas);\n    this.textGroups.B.style.left = `${screenPosB.x}px`;\n    this.textGroups.B.style.top = `${screenPosB.y}px`;\n    this.textGroups.B.innerHTML = `\n                <div>Basin B</div>\n                <div>h_B: ${(this.physics.h_B * 100).toFixed(1)} cm</div>\n                `;\n\n    const screenPosC = this.toScreenPosition(posC, this.camera, canvas);\n    this.textGroups.C.style.left = `${screenPosC.x}px`;\n    this.textGroups.C.style.top = `${screenPosC.y}px`;\n    this.textGroups.C.innerHTML = `\n                <div>Basin C</div>\n                <div>h_C: ${(this.physics.h_C * 100).toFixed(1)} cm</div>\n                `;\n\n    const screenPosJet = this.toScreenPosition(posJet, this.camera, canvas);\n    this.textGroups.Jet.style.left = `${screenPosJet.x}px`;\n    this.textGroups.Jet.style.top = `${screenPosJet.y}px`;\n    this.textGroups.Jet.innerHTML = `\n                <div>Jet</div>\n                <div>v_4: ${this.physics.v4.toFixed(2)} m/s</div>\n                <div>h_jet: ${(this.h_jet * 100).toFixed(1)} cm</div>\n                `;\n\n    this.textGroups.Time.style.left = `50%`;\n    this.textGroups.Time.style.top = `20px`;\n    const status = this.physics.isStable\n      ? \"STABLE (B empty)\"\n      : this.guiParams.isRunning\n      ? \"RUNNING\"\n      : \"PAUSED\";\n    this.textGroups.Time.innerHTML = `\n                <div>Time: ${this.physics.t.toFixed(2)} s</div>\n                <div>State: ${status}</div>\n                `;\n  }\n\n  onWindowResize() {\n    const aspect = this.container.clientWidth / this.container.clientHeight;\n    const viewSize = 15;\n\n    this.camera2D.left = -viewSize * aspect;\n    this.camera2D.right = viewSize * aspect;\n    this.camera2D.top = viewSize;\n    this.camera2D.bottom = -viewSize;\n    this.camera2D.updateProjectionMatrix();\n\n    this.camera3D.aspect = aspect;\n    this.camera3D.updateProjectionMatrix();\n\n    this.renderer.setSize(\n      this.container.clientWidth,\n      this.container.clientHeight\n    );\n  }\n\n  // --- *** REVERTED ***: animate()\n  animate() {\n    requestAnimationFrame(this.animate);\n\n    if (this.guiParams.viewMode === \"3D\") {\n      this.controls.update();\n    }\n\n    if (this.guiParams.isRunning) {\n      // Get the real time delta, uncapped\n      const delta = this.clock.getDelta() * this.guiParams.timeScale;\n\n      this.elapsedTime += delta;\n\n      if (!this.physics.isStable) {\n        this.physics.step(delta);\n        this.updateWaterMeshes();\n        this.updateWaterColors(delta);\n      } else {\n        // If stable, stop running the simulation automatically\n        this.guiParams.isRunning = false;\n        this.clock.stop();\n      }\n\n      this.updateCascade(delta); // Use the new curve update\n    } else {\n      // Even when paused, allow the cascade to hide\n      this.updateCascade(0.0);\n    }\n\n    // *** NEW ***: Call this every frame\n    this.updatePipeWaterLevels();\n\n    this.updateTextLabels();\n    this.renderer.render(this.scene, this.camera);\n  }\n}\n\n// Initialize when DOM ready\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  try {\n    new HeronFountainScene(\"scene-container\");\n  } catch (e) {\n    console.error(\"Impossibile inizializzare la scena:\", e);\n    document.GetElementById(\"scene-container\").innerHTML =\n      \"<h3>Errore durante l'inizializzazione della simulazione.</h3><pre>\" +\n      e.stack +\n      \"</pre>\";\n  }\n});"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$dyjou","$ilwiq","$9sWXr","$5Rd1x","$8482652b5247a78d$var$HeronPhysics","alpha","beta","gamma","rho","g","p_atm","wallThickness","S_B","S_C","S_A","V_D0","h_B0_ref","h_C0_ref","h_6","H","eta","S","L1","L2","B1","Math","PI","B2","y0","EPS_DHB","H_EPSILON","T_GUARD","t","h_A","h_B","h_C","v2","v4","isStable","p_D","reset","delta_V_reset","V_D","system","delta_V","deltaP_AB","deltaP_C4","sqrt","max","dhA_dt","step","dt","dhB_dt","dhC_dt","abs","$8482652b5247a78d$var$HeronFountainScene","containerId","container","document","getElementById","guiParams","isRunning","timeScale","viewMode","playPause","handlePlayPause","resetAll","clock","Clock","elapsedTime","scene","Scene","renderer","WebGLRenderer","antialias","controls","camera2D","camera3D","camera","h_jet","currentColors","themeObserver","scale","physics","waterA","waterB","waterC","waterCascade","waterPipe14","waterPipe56","pipe56","cascadeCurve","textOverlay","textGroups","dyeMassA","r","b","dyeMassB","dyeMassC","initialConcentration","H_scaled","h6_scaled","worldWidth","worldDepth","internalWallBCH","topBasinY","topBasinHeight","pipeInnerRadius","pipeOuterRadius","jetRadius","initThree","setupSceneGeometry","setupGUI","addTextLabels","animate","bind","getCurrentTheme","documentElement","getAttribute","updateSceneTheme","theme","background","Color","setupThemeObserver","MutationObserver","mutationsList","mutation","type","attributeName","observe","attributes","setSize","clientWidth","clientHeight","setPixelRatio","min","window","devicePixelRatio","shadowMap","enabled","appendChild","domElement","aspect","OrthographicCamera","viewSize","position","set","lookAt","PerspectiveCamera","OrbitControls","enableDamping","dampingFactor","target","ambientLight","AmbientLight","add","directionalLight","DirectionalLight","castShadow","addEventListener","onWindowResize","waterMaterial","MeshPhysicalMaterial","transmission","thickness","roughness","ior","transparent","opacity","side","DoubleSide","depthWrite","glassMaterial","color","basinWidth","basinDepth","waterAMaterial","waterBMaterial","waterCMaterial","waterGeom","BoxGeometry","Mesh","renderOrder","x","createWall","w","h","d","y","z","geom","mesh","clone","totalHeight","s","innerR_scaled","outerR_scaled","createHollowPipe","outerR","innerR","height","y_center","shape","Shape","absarc","hole","Path","holes","push","ExtrudeGeometry","depth","bevelEnabled","rotation","waterPipeGeom1","CylinderGeometry","visible","waterPipeGeom2","cascadeMaterial","path","LineCurve3","Vector3","tubeGeometry","TubeGeometry","gui","default","title","name","onChange","value","resetColors","volA0","volB0","volC0","material","setRGB","stop","updateWaterMeshes","updateTextLabels","updateWaterColors","start","hA_s","hB_s","hC_s","updateCascade","G","nozzleX","nozzleZ","nozzleY","waterATopY","angleRad","v_y0","sin","v_x0","cos","finalY_target","a","discriminant","timeToFall","horizontalOffset","isNaN","p0","p3","t_apex","actualApexY","p1","p2","CubicBezierCurve3","geometry","dispose","volA","volB","volC","flowVolume_CA","flowVolume_AB","concR_C","concG_C","concB_C","massR_flow","massG_flow","massB_flow","concR_A","concG_A","concB_A","clamp","val","cR_A","cG_A","cB_A","cR_B","cG_B","cB_B","cR_C","cG_C","cB_C","copy","updatePipeWaterLevels","h_min_scaled","h_A_unscaled","h_B_unscaled","waterHeight_scaled","waterHeight_unscaled","H_unscaled","waterBottom_scaled","h_pipe_unscaled","h_pipe_scaled","remove","createElement","className","createLabel","div","A","B","C","Time","Jet","toScreenPosition","vector3","canvas","width","vector","project","posA","posB","posC","posJet","screenPosA","style","left","top","innerHTML","toFixed","screenPosB","screenPosC","screenPosJet","status","right","bottom","updateProjectionMatrix","requestAnimationFrame","update","delta","getDelta","render","e","console","error","GetElementById","stack"],"version":3,"file":"heron_fountain_simulation.ff38a15d.js.map"}